#!/usr/local/bin/ruby
#
# racc
#
#   Copyright (c) 1999,2000 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
#
#   This program is free software.
#   You can distribute/modify this program under the terms of
#   the GNU Lesser General Public License version 2 or later.
#

##### parse arg ------------------------------------------------

require 'getopts'

def usage( status = 1 )
  $stderr.print <<MESSAGE

usage: racc.rb [ options ] <source file>

  options

    -g   output parser for user level debugging
    -v   make <filename>.output file
    -E   output file which don't need runtime
    -V   report message time to time
    -l   turn off line number converting (for ruby<1.4.4)
    -a   do not omit action call
    -c   syntax check only

    -o<outfile>   file name of output [<fname>.tab.rb]
    -e<ruby-path> make output file executable ('ruby' to default)
    -n<classname> use <classname> for name of parser class
    -h<header>    use <header> file for 'header' code
    -i<inner>     use <inner> file for 'inner' code
    -f<footer>    use <footer> file for 'footer' code
    -O<outfile>   file name of verbose output [<fname>.output]

    --help        print this message and quit
    --version     print version and quit
    --copyright   print copyright and quit

MESSAGE
#
# and, undocumented options :-)
#
# -P          report profile
#
# -R<req>     require <req> instead of 'racc/libracc'
# -D<flags>   set (racc's) debug flags
# -X<req>     make output file require <req> instead of 'racc/parser'
# -S<super>   replace super class of parser by <super>
# -T[ia]      i: index table,  a: alist table
#
  exit status
end
$USAGE = 'usage'

getopts( "acglvEPV",
  'o:', 'n:', 'h:', 'i:', 'f:', 'e:', 'O:',
  'R:', 'D:', 'X:', 'S:', 'T:',
  'help', 'version', 'copyright' ) or usage 1


require $OPT_R || 'racc/libracc'

if $OPT_help then
  usage 0
end

if $OPT_version then
  print "racc version #{Racc::Version}\n"
  exit 0
end

if $OPT_copyright then
  print <<S
racc version #{Racc::Version}
Copyright (c) 1999,2000 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
S
  exit 0
end

if ARGV.size != 1 then
  usage 1
end


##### lib --------------------------------------------------

require 'amstd/rubyemu'
require 'amstd/rbparams'

def fchk( fname )
  fn = File.expand_path( fname )
  unless File.exist? fn then
    raise Racc::RaccError, "no such file: #{fname}"
  end
  fn
end

def any_to_file( arg, mode, &block )
  case arg
  when String
    f = File.open( fchk(arg), mode, &block )
  when IO
    f = arg
    yield arg
  else
    arg.must String, IO
  end

  f
end

def connect_f( from, to )
  from.each {|line| to.write line }
  to.puts
end

def connect( from, to )
  any_to_file( from, 'r' ) do |ff|
    any_to_file( to, 'w' ) do |tf|
      connect_f( ff, tf )
    end
  end
end

def make_filename( sfile, suffix )
  temp = sfile.split( '.' )
  if temp.size == 1 then
    return( sfile + suffix )
  else
    temp.pop
    return( temp.join('.') + suffix )
  end
end



def connect_part_raccfile( srcfn, outf, name )
  name.downcase!
  beg = false
  partexp = /\A----+\s*#{name}\s*(=)?/i

  File.open( srcfn ) do |f|
    while line = f.gets do
      break if partexp === line
    end

    if $1 then
      $'.strip.split( /\s+/o ).each {|fname| connect fname, outf }
    end

    while line = f.gets do
      break if /\A----/o === line
      outf.write line
    end
  end
end

def connect_part( srcfn, f, opt, *part_name )
  if opt then
    opt.split(':').each do |fn|
      connect fchk(fn), f
    end
  else
    part_name.each do |part|
      connect_part_raccfile srcfn, f, part
    end
  end
end



def get_lap
  begt = Time.times.utime
  yield
  endt = Time.times.utime
  endt - begt
end

def pcompile( racc, srcstr, srcfn )
  times = []
  times.push [ 'parse',   get_lap{ racc.parse(srcstr, srcfn) } ]
  times.push [ 'state',   get_lap{ racc.nfa } ]
  times.push [ 'resolve', get_lap{ racc.dfa } ]
  times
end

def report_profile( prof )
  out = $stderr

  whole = 0
  prof.each do |arr|
    whole += arr[1]
  end
  if whole == 0 then
    whole = 0.01
  end

  out.puts '--task-----------+--sec------+---%-'

  prof.each do |arr|
    name, time = arr
    out.printf( "%-19s %s %3d%%\n",
                name, pjust(time,4,4), (time/whole * 100).to_i )
  end

  out.puts '-----------------+-----------+-----'
  out.printf( "%-20s%s\n",
              'total', pjust(whole,4,4) )
end

def pjust( num, i, j )
  /(\d+)(\.\d+)?/o === num.to_s
  str = $1.rjust(i)
  if $2 then
    str << $2.ljust(j+1)[0,j+1]
  end

  str
end


def embed( feature, f )
  f.print <<S
###### #{feature}

unless $".index '#{feature}.rb' then
$".push '#{feature}.rb'
S
  flag = false
  File.foreach( RubyEmuration.find_feature feature ) do |line|
    f.print line
  end
  f.puts "end   # end of #{feature}"
end


##### main -------------------------------------------------


def set_flags( racc )
  # overwrite source's
  racc.debug_parser = true  if $OPT_g
  racc.convert_line = false if $OPT_l
  racc.omit_action  = false if $OPT_a
  racc.make_profile = true  if $OPT_P
  racc.verbose      = true  if $OPT_V

  if $DEBUG then
    $OPT_D ||= ''
  end
  if $OPT_D then
    $stdout.sync = true
    racc.debug    = true
    racc.d_parse  = true if /p/i === $OPT_D
    racc.d_rule   = true if /r/i === $OPT_D
    racc.d_token  = true if /t/i === $OPT_D
    racc.d_state  = true if /s/i === $OPT_D
    racc.d_reduce = true if /e/i === $OPT_D
    racc.d_shift  = true if /h/i === $OPT_D
  end
end


def write_table_file( racc, srcfn )
  tabfn = $OPT_o || make_filename( srcfn, '.tab.rb' )
  class_name = $OPT_n || racc.class_name

  File.open( tabfn, 'w' ) do |f|
    if $OPT_e then
      f.puts "#!#{$OPT_e == 'ruby' ? RubyParams::RUBY_PATH : $OPT_e}"
    end
    if $OPT_E then
      f.print <<S
#
# #{tabfn}: generated by racc (runtime embedded)
#

S
      embed 'racc/parser.rb', f; f.puts
    else
      f.puts
      f.puts  "require '#{$OPT_X || 'racc/parser'}'"
    end
    connect_part srcfn, f, $OPT_h, 'header', 'prepare'
    f.puts  "class #{class_name} < #{$OPT_S || 'Racc::Parser'}\n"
    connect_part srcfn, f, $OPT_i, 'inner'
    unless $OPT_T then
      racc.source f
    else
      racc.send( $OPT_T == 'a' ? :alist_table : :index_table, f )
    end
    f.puts  "end"
    connect_part srcfn, f, $OPT_f, 'footer', 'driver'
  end

  if $OPT_e then
    File.chmod( 0755, tabfn )
  else
    File.chmod( 0644, tabfn )
  end
end


def report_conflict( racc )
  lo = 0
  sr = 0
  rr = 0
  racc.statetable.each do |st|
    sr += st.srconf.size if st.srconf
    rr += st.rrconf.size if st.rrconf
  end

  if lo > 0 then
    $stderr.puts "#{lo} logic error found"
  end
  if sr > 0 then
    $stderr.puts "#{sr} shift/reduce conflicts"
  end
  if rr > 0 then
    $stderr.puts "#{rr} reduce/reduce conflicts"
  end
end


def report_useless( racc )
  nt = 0
  rl = 0
  racc.tokentable.each_nonterm do |t|
    if t.useless? then
      nt += 1
    end
  end
  racc.ruletable.each do |r|
    if r.useless? then
      rl += 1
    end
  end
  if nt > 0 or rl > 0 then
    $stderr.printf "%s%s%s\n",
                   nt > 0                 ? "#{nt} useless nonterminal" : '',
                   ((nt > 0) && (rl > 0)) ? ' and '                     : '',
                   rl > 0                 ? "#{rl} useless rule"        : ''
  end
end


def racc_main( racc, srcfn )
  srcstr = nil
  File.open( fchk(srcfn), 'r' ) {|f| srcstr = f.read }

  if $OPT_P then
    prof = pcompile( racc, srcstr, srcfn )
  else
    racc.parse( srcstr, srcfn )
    if $OPT_c then
      puts 'syntax ok'
      exit 0
    end
    set_flags racc
    racc.compile
  end

  write_table_file racc, srcfn

  if prof then
    report_profile prof
  end

  if $OPT_v then
    output_fn = $OPT_O || make_filename( $OPT_o || srcfn, '.output' )
    File.open( output_fn, 'w' ) do |f|
      racc.output f
    end
  end

  report_conflict racc
  report_useless racc
end


begin
  srcfn = ARGV[0]
  racc = Racc::Compiler.new
  racc_main racc, srcfn
rescue Racc::ParseError, Racc::ScanError, Racc::RaccError
  raise if racc.debug
  msg = $!.to_s
  unless /\A\d/ === msg then
    msg[0,0] = ' '
  end
  $stderr.puts "#{File.basename $0}:#{srcfn}:" + msg
  exit 1
end
