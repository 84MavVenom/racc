#!/usr/local/bin/ruby
#
# racc version 0.10.5
#
#   Copyright (c) 1999 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
#
#   This program is free software.
#   You can distribute/modify this program under the terms of
#   the GNU Lesser General Public License version 2 or later.
#

##### parse arg ------------------------------------------------

require 'parsearg'

def usage
  print <<MESSAGE

usage: racc.rb [ options ] <source file>

  options

    -g   output parser for user level debugging
    -v   make <filename>.output file
    -E   output file which don't need runtime

    -o<outfile>   designate output file name (default <fname>.tab.rb)
    -e<ruby-path> make output file executable
    -n<classname> use <classname> for name of parser class
    -h<header>    use <header> file for 'header' code
    -i<inner>     use <inner> file for 'inner' code
    -f<footer>    use <footer> file for 'footer' code

    --version     print version and quit
    --help        print this message and quit

MESSAGE
#
# and, undocumented options :-)
#
# -P   report profile
#
# -R<req>     require <req> instead of 'racc/libracc'
# -D<flags>   set (racc's) debug flags (collection of [prtseh])
# -X<req>     make output file require <req> instead of 'racc/parser'
# -S<super>   replace super class of parser by <super>
#
end
$USAGE = 'usage'

parseArgs( 1, nil, "vgPE",
  'o:', 'n:', 'h:', 'i:', 'f:', 'e:',
  'R:', 'D:', 'X:', 'S:',
  'version', 'help' )


if $OPT_R then
  require $OPT_R
else
  require 'racc/libracc'
end

if $OPT_version then
  print "racc version #{Racc::Version}\n"
  exit 0
end

if $OPT_help then
  usage
  exit 0
end


##### lib --------------------------------------------------


def fchk( fname )
  fn = File.expand_path( fname )
  unless File.exist? fn then
    raise ArgumentError, "no such file: #{fname}"
  end
  fn
end

def any_to_file( arg, mode, &block )
  case arg
  when String
    f = File.open( fchk(arg), mode, &block )
  when IO
    f = arg
    yield arg
  else
    arg.must String, IO
  end

  f
end

def connect_f( from, to )
  from.each {|line| to.write line }
  to.puts
end

def connect( from, to )
  any_to_file( from, 'r' ) do |ff|
    any_to_file( to, 'w' ) do |tf|
      connect_f( ff, tf )
    end
  end
end

def make_filename( sfile, suffix )
  temp = sfile.split( '.' )
  if temp.size == 1 then
    return( sfile + suffix )
  else
    temp.pop
    return( temp.join('.') + suffix )
  end
end



def connect_part_raccfile( srcfn, outf, name )
  name.downcase!
  beg = false
  partexp = /\A----+\s*#{name}\s*(=)?/i

  File.open( srcfn ) do |f|
    while line = f.gets do
      break if partexp === line
    end

    if $1 then
      $'.strip.split( /\s+/o ).each {|fname| connect fname, outf }
    end

    while line = f.gets do
      break if /\A----/o === line
      outf.write line
    end
  end
end

def connect_part( srcfn, f, opt, *part_name )
  if opt then
    opt.split(':').each do |fn|
      connect fchk(fn), f
    end
  else
    part_name.each do |part|
      connect_part_raccfile srcfn, f, part
    end
  end
end



def get_lap
  begt = Time.times.utime
  yield
  endt = Time.times.utime
  endt - begt
end

def pcompile( racc, srcstr, srcfn )
  times = []
  times.push [ 'setup',   get_lap{ racc.reset } ]
  times.push [ 'parse',   get_lap{ racc.parse(srcstr, srcfn) } ]
  times.push [ 'cache',   get_lap{ racc.init_rule } ]
  times.push [ 'state',   get_lap{ racc.init_state } ]
  times.push [ 'resolve', get_lap{ racc.resolve } ]

  return times
end

def report_profile( srcs )
  whole = 0
  $OPT_P.each do |arr|
    whole += arr[1]
  end
  if whole == 0 then
    whole = 0.01
  end

  puts '--task-----------+--sec------+---%-'

  $OPT_P.each do |arr|
    name, time = arr
    printf( "%-19s %s %3d%%\n",
            name, pjust(time,4,4), (time/whole * 100).to_i )
  end

  puts '-----------------+-----------+-----'
  printf( "%-20s%s\n",
          'total', pjust(whole,4,4) )
end

def pjust( num, i, j )
  /(\d+)(\.\d+)?/o === num.to_s
  str = $1.rjust(i)
  if $2 then
    str << $2.ljust(j+1)[0,j+1]
  end

  return str
end


def embed( feature, f )
  f.print <<S
###### #{feature}

unless $".index '#{feature}.rb' then
$".push '#{feature}.rb'
S
  flag = false
  File.foreach( RubyEmuration.find_feature feature ) do |line|
    if /\A###/ === line then
      flag = true
      next
    end
    next unless flag
    f.print line
  end
  f.puts "end   # end of #{feature}"
end


##### main -------------------------------------------------

GC.disable   # :-)

racc = Racc::Core.new

if $OPT_g then
  racc.dsrc = true
end
if $OPT_D then
  $stdout.sync = true
  racc.debug    = true
  racc.d_prec   = true if /p/io === $OPT_D
  racc.d_rule   = true if /r/io === $OPT_D
  racc.d_token  = true if /t/io === $OPT_D
  racc.d_state  = true if /s/io === $OPT_D
  racc.d_reduce = true if /e/io === $OPT_D
  racc.d_shift  = true if /h/io === $OPT_D
end


srcfn = ARGV[0]
srcstr = nil
File.open( fchk(srcfn), 'r' ) {|f| srcstr = f.read }

if $OPT_P then
  $OPT_P = pcompile( racc, srcstr, srcfn )
else
  racc.compile( srcstr, srcfn )
end


tabfn = $OPT_o || make_filename( srcfn, '.tab.rb' )
class_name = $OPT_n || racc.class_name

File.open( tabfn, 'w' ) do |f|
  if $OPT_e then
    f.puts "#!#{$OPT_e}"
  end
  if $OPT_E then
    require 'amstd/rubyemu'
    f.print <<S
#
# #{tabfn}: generated by racc (runtime embedded)
#

S
    embed 'amstd/bug',   f ; f.puts
    embed 'racc/parser', f ; f.puts
  else
    f.puts
    f.puts  "require '#{$OPT_X || 'racc/parser'}'"
  end
  connect_part srcfn, f, $OPT_h, 'header', 'prepare'
  f.puts  "class #{class_name} < #{$OPT_S || 'Racc::Parser'}\n"
  connect_part srcfn, f, $OPT_i, 'inner'
  racc.source f
  f.puts  "end"
  connect_part srcfn, f, $OPT_f, 'footer', 'driver'
end

if $OPT_e then
  File.chmod( 0755, tabfn )
else
  File.chmod( 0644, tabfn )
end


if $OPT_P then
  report_profile $OPT_P
end

if $OPT_v then
  output_fn = make_filename( srcfn, '.output' )

  File.open( output_fn, 'w' ) do |f|
    if racc.rrconf.size > 0 then
      f.write racc.rrconf.join("\n")
      f.puts
    end
    if racc.srconf.size > 0 then
      f.write racc.srconf.join("\n")
      f.puts
    end
    if racc.logic.size > 0 then
      f.write racc.logic.join("\n")
      f.puts
    end

    racc.output f
  end
end


if racc.logic.size > 0 then
  print "#{racc.logic.size} logic error found\n"
end

if racc.rrconf.size > 0 then
  print "#{racc.rrconf.size} reduce/reduce conflicts\n"
end

if racc.srconf.size > 0 then
  print "#{racc.srconf.size} shift/reduce conflicts\n"
end
