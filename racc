#!/usr/local/bin/ruby
#
# racc version 0.14.4
#
#   Copyright (c) 1999,2000 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
#
#   This program is free software.
#   You can distribute/modify this program under the terms of
#   the GNU Lesser General Public License version 2 or later.
#

##### parse arg ------------------------------------------------

require 'getopts'

def usage( status = 1 )
  $stderr.print <<MESSAGE

usage: racc.rb [ options ] <source file>

  options

    -g   output parser for user level debugging
    -v   make <filename>.output file
    -E   output file which don't need runtime
    -V   report status time to time

    -o<outfile>   file name of output [<fname>.tab.rb]
    -e<ruby-path> make output file executable ('ruby' to default)
    -n<classname> use <classname> for name of parser class
    -h<header>    use <header> file for 'header' code
    -i<inner>     use <inner> file for 'inner' code
    -f<footer>    use <footer> file for 'footer' code
    -O<outfile>   file name of verbose output [<outfile>.output]

    --help        print this message and quit
    --version     print version and quit
    --copyright   print copyright and quit

MESSAGE
#
# and, undocumented options :-)
#
# -c          syntax check only
# -P          report profile
#
# -R<req>     require <req> instead of 'racc/libracc'
# -D<flags>   set (racc's) debug flags (collection of [prtseh])
# -X<req>     make output file require <req> instead of 'racc/parser'
# -S<super>   replace super class of parser by <super>
# -T[ia]      i: index table,  a: alist table
#
  exit status
end
$USAGE = 'usage'

getopts( "cvgPEV",
  'o:', 'n:', 'h:', 'i:', 'f:', 'e:', 'O:',
  'R:', 'D:', 'X:', 'S:', 'T:',
  'help', 'version', 'copyright' ) or usage 1


require $OPT_R || 'racc/libracc'

if $OPT_help then
  usage 0
end

if $OPT_version then
  print "racc version #{Racc::Version}\n"
  exit 0
end

if $OPT_copyright then
  print <<S
racc version #{Racc::Version}
copyright (c) 1999,2000 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
S
  exit 0
end

if ARGV.size != 1 then
  usage 1
end


##### lib --------------------------------------------------

require 'amstd/rubyemu'
require 'amstd/rbparams'

def fchk( fname )
  fn = File.expand_path( fname )
  unless File.exist? fn then
    raise ArgumentError, "no such file: #{fname}"
  end
  fn
end

def any_to_file( arg, mode, &block )
  case arg
  when String
    f = File.open( fchk(arg), mode, &block )
  when IO
    f = arg
    yield arg
  else
    arg.must String, IO
  end

  f
end

def connect_f( from, to )
  from.each {|line| to.write line }
  to.puts
end

def connect( from, to )
  any_to_file( from, 'r' ) do |ff|
    any_to_file( to, 'w' ) do |tf|
      connect_f( ff, tf )
    end
  end
end

def make_filename( sfile, suffix )
  temp = sfile.split( '.' )
  if temp.size == 1 then
    return( sfile + suffix )
  else
    temp.pop
    return( temp.join('.') + suffix )
  end
end



def connect_part_raccfile( srcfn, outf, name )
  name.downcase!
  beg = false
  partexp = /\A----+\s*#{name}\s*(=)?/i

  File.open( srcfn ) do |f|
    while line = f.gets do
      break if partexp === line
    end

    if $1 then
      $'.strip.split( /\s+/o ).each {|fname| connect fname, outf }
    end

    while line = f.gets do
      break if /\A----/o === line
      outf.write line
    end
  end
end

def connect_part( srcfn, f, opt, *part_name )
  if opt then
    opt.split(':').each do |fn|
      connect fchk(fn), f
    end
  else
    part_name.each do |part|
      connect_part_raccfile srcfn, f, part
    end
  end
end



def get_lap
  begt = Time.times.utime
  yield
  endt = Time.times.utime
  endt - begt
end

def pcompile( racc, srcstr, srcfn )
  times = []
  times.push [ 'parse',   get_lap{ racc.parse(srcstr, srcfn) } ]
  times.push [ 'state',   get_lap{ racc.nfa } ]
  times.push [ 'resolve', get_lap{ racc.dfa } ]

  return times
end

def report_profile( srcs )
  out = $stderr

  whole = 0
  $OPT_P.each do |arr|
    whole += arr[1]
  end
  if whole == 0 then
    whole = 0.01
  end

  out.puts '--task-----------+--sec------+---%-'

  $OPT_P.each do |arr|
    name, time = arr
    out.printf( "%-19s %s %3d%%\n",
                name, pjust(time,4,4), (time/whole * 100).to_i )
  end

  out.puts '-----------------+-----------+-----'
  out.printf( "%-20s%s\n",
              'total', pjust(whole,4,4) )
end

def pjust( num, i, j )
  /(\d+)(\.\d+)?/o === num.to_s
  str = $1.rjust(i)
  if $2 then
    str << $2.ljust(j+1)[0,j+1]
  end

  str
end


def embed( feature, f )
  f.print <<S
###### #{feature}

unless $".index '#{feature}.rb' then
$".push '#{feature}.rb'
S
  flag = false
  File.foreach( RubyEmuration.find_feature feature ) do |line|
    f.print line
  end
  f.puts "end   # end of #{feature}"
end


##### main -------------------------------------------------

def racc_main


dopt = {}
dopt[ 'debug-src' ] = $OPT_g ? true : false
dopt[ 'verbose' ] = $OPT_V ? true : false
dopt[ 'profile' ] = $OPT_P ? true : false

if $OPT_D then
  $stdout.sync = true
  dopt[ 'debug' ]  = true
  dopt[ 'prec' ]   = true if /p/i === $OPT_D
  dopt[ 'rule' ]   = true if /r/i === $OPT_D
  dopt[ 'token' ]  = true if /t/i === $OPT_D
  dopt[ 'state' ]  = true if /s/i === $OPT_D
  dopt[ 'reduce' ] = true if /e/i === $OPT_D
  dopt[ 'shift' ]  = true if /h/i === $OPT_D
end

racc = Racc::Compiler.new( dopt )
$racc = racc


srcfn = ARGV[0]
srcstr = nil
File.open( fchk(srcfn), 'r' ) {|f| srcstr = f.read }


if $OPT_P then
  $OPT_P = pcompile( racc, srcstr, srcfn )
elsif $OPT_c then
  racc.parse( srcstr, srcfn )
  puts 'syntax ok'
  exit 0
else
  racc.compile( srcstr, srcfn )
end


tabfn = $OPT_o || make_filename( srcfn, '.tab.rb' )
class_name = $OPT_n || racc.class_name

File.open( tabfn, 'w' ) do |f|
  if $OPT_e then
    f.puts "#!#{$OPT_e == 'ruby' ? RubyParams::RUBY_PATH : $OPT_e}"
  end
  if $OPT_E then
    f.print <<S
#
# #{tabfn}: generated by racc (runtime embedded)
#

S
    embed 'racc/parser.rb', f; f.puts
  else
    f.puts
    f.puts  "require '#{$OPT_X || 'racc/parser'}'"
  end
  connect_part srcfn, f, $OPT_h, 'header', 'prepare'
  f.puts  "class #{class_name} < #{$OPT_S || 'Racc::Parser'}\n"
  connect_part srcfn, f, $OPT_i, 'inner'
  unless $OPT_T then
    racc.source f
  else
    racc.send( $OPT_T == 'a' ? :alist_table : :index_table, f )
  end
  f.puts  "end"
  connect_part srcfn, f, $OPT_f, 'footer', 'driver'
end

if $OPT_e then
  File.chmod( 0755, tabfn )
else
  File.chmod( 0644, tabfn )
end


if $OPT_P then
  report_profile $OPT_P
end

if $OPT_v then
  output_fn = $OPT_O || make_filename( $OPT_o || srcfn, '.output' )

  File.open( output_fn, 'w' ) do |f|
    racc.output f
  end
end


lo = 0
sr = 0
rr = 0
racc.statetable.each do |st|
  sr += st.srconf.size if st.srconf
  rr += st.rrconf.size if st.rrconf
end

if lo > 0 then
  $stderr.puts "#{lo} logic error found"
end
if sr > 0 then
  $stderr.puts "#{sr} shift/reduce conflicts"
end
if rr > 0 then
  $stderr.puts "#{rr} reduce/reduce conflicts"
end

end   # def racc_main


begin
  racc_main
rescue
  raise if $racc.debug
  $stderr.puts "#{File.basename $0}: " + $!.to_s
  exit 1
end
