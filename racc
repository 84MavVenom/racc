#!/usr/local/bin/ruby
#
# racc version 0.10.1
#
#     Copyright (c) 1999 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
#

$stdout.sync = true


GC.disable


##### parse arg ------------------------------------------------

require 'parsearg'

def usage
  print <<MESSAGE

usage: racc.rb [ options ] <source file>

  options

    -g   output source for (user) debugging
    -v   verbose mode --- make r.output file
    -P   report simple profile

    -o<outfile>   designate output file name.
                    default '<basename>.tab.rb'
    -e<ruby-path> output executable ruby source file
    -n<classname> use <classname> for name of parser class
    -i<inner>     use <inner> file for 'inner' code
    -p<prepare>   use <prepare> file for 'prepare' code
    -d<driver>    use <driver> file for 'driver' code

    --version     print version and quit
    --help(-h)    print this message and quit

MESSAGE

end
$USAGE = 'usage'


parseArgs( 1, nil, "vhPgG",
  'o:', 'n:', 'i:', 'p:', 'd:', 'e:', 'R:', 'D:', 'X:', 'S:',
  'version', 'help' )


if $OPT_R then
  require $OPT_R
else
  require 'racc/libracc'
end

if $OPT_version then
  print "racc version #{Racc::Version}\n"
  exit 0
end

if $OPT_help or $OPT_h then
  usage
  exit 0
end


##### lib --------------------------------------------------


def fchk( fname )
  fn = File.expand_path( fname )
  unless File.exist? fn then
    raise ArgumentError, "no such file: #{fname}"
  end
  fn
end

def any_to_file( arg, mode, &block )
  case arg
  when String
    f = File.open( fchk(arg), mode, &block )
  when IO
    f = arg
    yield arg
  else
    arg.must String, IO
  end

  f
end

def connect_f( from, to )
  from.each {|line| to.write line }
  to.puts
end

def connect( from, to )
  any_to_file( from, 'r' ) do |ff|
    any_to_file( to, 'w' ) do |tf|
      connect_f( ff, tf )
    end
  end
end

def make_filename( sfile, suffix )
  temp = sfile.split( '.' )
  if temp.size == 1 then
    return( sfile + suffix )
  else
    temp.pop
    return( temp.join('.') + suffix )
  end
end



def connect_part_raccfile( srcfn, outf, name )
  name.downcase!
  beg = false
  partexp = /\A----+\s*#{name}\s*(=)?/i

  File.open( srcfn ) do |f|
    while line = f.gets do
      break if partexp === line
    end

    if $1 then
      $'.strip.split( /\s+/o ).each {|fname| connect fname, outf }
    end

    while line = f.gets do
      break if /\A----/o === line
      outf.write line
    end
  end
end

def connect_part( srcfn, f, opt, part_name )
  if opt then
    opt.split(':').each do |fn|
      connect fchk(fn), f
    end
  else
    connect_part_raccfile srcfn, f, part_name
  end
end



def get_lap
  begt = Time.times.utime
  yield
  endt = Time.times.utime
  endt - begt
end

def pcompile( racc, srcstr, srcfn )
  times = []
  times.push [ 'setup',   get_lap{ racc.reset } ]
  times.push [ 'parse',   get_lap{ racc.parse(srcstr, srcfn) } ]
  times.push [ 'cache',   get_lap{ racc.init_rule } ]
  times.push [ 'state',   get_lap{ racc.init_state } ]
  times.push [ 'resolve', get_lap{ racc.resolve } ]

  return times
end

def report_profile( srcs )
  whole = 0
  $OPT_P.each do |arr|
    whole += arr[1]
  end
  if whole == 0 then
    whole = 0.01
  end

  puts '--task-------------+--sec------+---%-'

  $OPT_P.each do |arr|
    name, time = arr
    printf( "%-19s %s %3d%%\n",
            name, pjust(time,4,4), (time/whole * 100).to_i )
  end

  puts '-------------------+-----------+-----'
  printf( "%-20s%s\n",
          'total', pjust(whole,5,4) )
end

def pjust( num, i, j )
  /(\d+)(\.\d+)?/o === num.to_s
  str = $1.rjust(i)
  if $2 then
    str << $2.ljust(j+1)[0,j+1]
  end

  return str
end



##### main -------------------------------------------------


racc = Racc.new

racc.dsrc = true if $OPT_g
if $OPT_D then
  racc.debug    = true
  racc.d_prec   = true if /p/io === $OPT_D
  racc.d_rule   = true if /r/io === $OPT_D
  racc.d_token  = true if /t/io === $OPT_D
  racc.d_state  = true if /s/io === $OPT_D
  racc.d_reduce = true if /e/io === $OPT_D
  racc.d_shift  = true if /h/io === $OPT_D
end


$stdout.sync = true if $DEBUG

srcfn = ARGV[0]
srcstr = nil
File.open( fchk(srcfn), 'r' ) {|f| srcstr = f.read }

if $OPT_P then
  $OPT_P = pcompile( racc, srcstr, srcfn )
else
  racc.compile( srcstr, srcfn )
end


tabfn = $OPT_o || make_filename( srcfn, '.tab.rb' )
class_name = $OPT_n || racc.class_name

File.open( tabfn, 'w' ) do |f|
  if $OPT_e then
    f.puts "#!#{$OPT_e}"
    f.puts
  end
  f.puts  "require '#{$OPT_X || 'racc/parser'}'"
  connect_part srcfn, f, $OPT_p, 'prepare'
  f.puts  "class #{class_name} < #{$OPT_S || 'Parser'}\n"
  connect_part srcfn, f, $OPT_i, 'inner'
  racc.source f
  f.puts  "end"
  connect_part srcfn, f, $OPT_d, 'driver'
end

if $OPT_e then
  File.chmod( 0755, tabfn )
else
  File.chmod( 0644, tabfn )
end


if $OPT_P then
  report_profile $OPT_P
end

if $OPT_v then
  output_fn = make_filename( srcfn, '.output' )

  File.open( output_fn, 'w' ) do |f|
    if racc.rrconf.size > 0 then
      f.write racc.rrconf.join("\n")
      f.puts
    end
    if racc.srconf.size > 0 then
      f.write racc.srconf.join("\n")
      f.puts
    end
    if racc.logic.size > 0 then
      f.write racc.logic.join("\n")
      f.puts
    end

    racc.output f
  end
end


if racc.logic.size > 0 then
  print "#{racc.logic.size} logic error found\n"
end

if racc.rrconf.size > 0 then
  print "#{racc.rrconf.size} reduce/reduce conflicts\n"
end

if racc.srconf.size > 0 then
  print "#{racc.srconf.size} shift/reduce conflicts\n"
end
