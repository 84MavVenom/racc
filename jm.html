. file index.html -------------------------------------------------------
<% header 'Racc User Manual' %>

<h1>Racc user manual</h1>

updated for version 1.3.4

<p>
Racc は文法規則から Ruby で書かれたパーサを生成するパーサジェネレータです。
パーサ生成アルゴリズムには yacc などと同じ LALR(1) を使用しています。

<ul>
<li><a href="usage.html">Racc の使い方</a>
<li><a href="command.html">racc コマンドリファレンス</a>
<li><a href="grammer.html">規則ファイル文法リファレンス</a>
<li><a href="parser.html">Parser クラスリファレンス</a>
<li><a href="debug.html">デバッグ情報</a>
<li><a href="changes.html">変更履歴</a>
</ul>

<% footer 1999 %>
. file usage.html --------------------------------------------------------
<% header 'Usage' %>

<h1>Racc の使い方</h1>

<h2>ひとの作ったパーサを使う</h2>

<p>
もうすでに文法ファイルがある場合です。この場合は単に racc コマンドが使えればよく、
文法ファイルの書きかたを覚えたりする必要はありません。

<p>
文法ファイルの名前が parse.y と仮定すると、コマンドラインから以下のように
打ちこむことで、パーサを含んだファイルが得られます。
<pre>

$ racc parse.y

</pre>
生成されるファイルはデフォルトでは "ファイル名.tab.rb" になります。
これは -o オプションで変更できます。


<h2>自分でパーサを作る</h2>

<p>
自分で racc の文法ファイルを記述する場合です。
racc は yacc を知っていることを前提にしていますので、もし知らないのなら
先に yacc を勉強しましょう。いきなり racc を使うのは不可能です。(これは断言できます)

<h3>概観</h3>
<p>
yacc は yyparse (関数)を生成しますが、racc は yyparse に相当する do_parse
メソッドを持ったパーサクラスを生成します。
生成されるクラスは全て Racc::Parser の下位クラスで、規則ファイル中で指定します。
規則ファイルの文法の詳細は、<a href="grammer.html">文法リファレンス</a>を
参照してください。

<h3>規則ファイル</h3>
<p>
以下には規則ファイルの文法の概略だけ書いておきます。<br>
まずは、全体の概形です。
<pre>

class MyParser

rule
  target : exp

  exp    : tok { print val[0] }
         | exp tok    # これはコメント
               { print val[1] }

  tok    : A
         | '+'
         | '-'       /* これもコメント */
end

</pre>
Rubyスクリプトのように class でクラス名を指定し、rule ... end の間に文法を記述します。
トークンは Ruby のローカル変数/定数として有効なものが使えます。
yacc だと終端記号を %token で指定する必要がありますが、racc ではそのような
指定は必要ありません。左辺に来ないトークンはすべて終端記号とみなされます。

<p>
アクションは、yacc と同じように規則のあとに { と } で囲んで指定します。
当然ながら、アクションは Ruby の文で記述します。<br>
yacc での $$ は Racc ではローカル変数 result で、$1,$2... は配列 val です。
result は val[0]($1) の値に初期化され、アクションを抜けたときの result の値が
左辺値になります。Racc ではアクション中の return はアクションから抜けるだけで、
パーズ自体は終わりません。<br>
アクション中からパーズを終了するには、メソッド yyaccept を使ってください。
<p>
演算子の優先順位、スタートルールなどの yacc の一般的な機能も用意されています。
ただしこちらも少し文法が違います。
<p>
yacc では生成されたコードに直接転写されるコードがありました。Racc でも同じように、
ユーザ指定のコードが書けます。racc ではクラスを生成するので、クラス定義の前/中/後の
三個所があります。Racc ではそれを上から順番に header inner footer と呼んでいます。

<h3>ユーザが用意すべきコード</h3>
<p>
パースのエントリポイントとなるメソッドは二つあります。ひとつは
do_parse で、こちらはトークンを パーサ#next_token から得ます。
もうひとつは yyparse で、こちらはスキャナから yield されることに
よってトークンを得ます。ユーザ側ではこのどちらか(両方でもいいけど)を
起動する簡単なメソッドを inner に書いてください。
これらメソッドの引数など、詳しいことはリファレンスを見てください。<br>
<a href="parser.html#do_parse">do_parse</a><br>
<a href="parser.html#yyparse">yyparse</a>
<p>
どちらのメソッドにも共通なのはトークンの形式です。必ずトークンシンボルと
その値の二要素を持つ配列を返すようにします。またスキャンが終了して、
もう送るものがない場合は [false,なにか] を返してください。これは一回
返せば十分です(逆に yyparse を使う場合は二回以上 yield しないこと)。
<p>
パーザは別に文字列処理にだけ使われるものではありませんが、実際問題として、
パーザを作る場面ではたいてい文字列のスキャナとセットで使うことが多いでしょう。
Ruby ならスキャナくらい楽勝で作れますが、高速なスキャナとなると実は難しかったり
します。そこで高速なスキャナを作成するためのライブラリも作っています。
詳しくは<a href="#scanner">「スキャナを作る」の項</a>を見てください。
<p>
さらに Racc には error トークンを使ったエラー回復機能もあります。<br>
yacc の yyerror() は Racc では <a href="parser.html">Parser#on_error</a>で、
エラーがおきたトークンとその値、値スタックの 3 引数をとります。
on_error はデフォルトでは例外 ParseError を発生します。<br>
ユーザがアクション中でパースエラーを発見した場合は、
メソッド yyerror を呼べばパーサがエラー回復モードに入ります。
このときは on_error は呼ばれないので、なにか報告をしたい時は
ユーザが明示的に on_error を呼んだりする必要があります。

<h3>パーザを生成する</h3>
<p>
これだけあればだいたい書けると思います。あとは、最初に示した方法でコンパイルし、
Ruby スクリプトを得ます。<br>
うまくいけばいいのですが、大きいものだと最初からはうまくいかないでしょう。
racc に -g オプションをつけてコンパイルし、@yydebug を true にすると
デバッグ用の出力が得られます。デバッグ出力はパーザの @racc_debug_out に
出力されます。(デフォルトは stderr。)<br>
また、racc に -v オプションをつけると、状態遷移表を読みやすい形で出力したファイル
(*.output)が得られます。どちらもデバッグの参考になるでしょう。


<h2>作ったパーザを配布する</h2>
<p>
Racc の生成したパーザは動作時にランタイムルーチンが必要になります。
具体的には parser.rb と cparse.so です。ただし cparse.so は単に
パースを高速化するためにあり、必須ではありません。これらのファイルを
自分でセットアップするのはなかなか面倒です。Racc をユーザみんなに
インストールしてもらうのも一つの手ですが、これでは不親切です。そこで
Racc では回避策を用意しました。

<p>
racc に -E オプションをつけてコンパイルすると必要なものを全部結合した
ファイルが得られます。これだとファイルはひとつだけなので扱いが楽です
(この形式のパーザが複数あったとしてもクラスやメソッドが衝突することは
ありません)。ただし cparse.so が使えませんので、必然的に動作は全て
Ruby スクリプトレベルで行われ、速度は低下します。ただしこれにも例外が
あって、配布先に既に Racc ランタイムがあるときは自動的にそちらが使われ
ます。


<h2><a name="scanner">おまけ：スキャナを作る</a></h2>
<p>
パーサを使うときは、たいてい文字列をトークンに切りわけてくれる
スキャナが必要になります。しかし実は Ruby は文字列の最初からトークンに
切りわけていくという作業があまり得意ではありません。正確に言うと、
簡単にできるのですが、非常に大きいオーバーヘッドがかかります。<br>
そのオーバーヘッドを回避しつつ、手軽にスキャナをつくれるように
Racc とは別に strscan というパッケージを提供しています。
strscan は<a href="http://www.ruby-lang.org/en/raa.html">RAA</a>か
<a href="http://www1.u-netsurf.ne.jp/~brew/mine/ja/">筆者のホームページ</a>
から取れるので、試してみてください。

<% footer 1999 %>
. file command.html -----------------------------------------------------------
<% header 'Racc Command' %>

<h1>Raccコマンドリファレンス</h1>

<hr>

<p>
racc [-o<var>filename</var>] [--output-file=<var>filename</var>]
     [-e<var>rubypath</var>] [--embedded=<var>rubypath</var>]
     [-v] [--verbose]
     [-O<var>filename</var>] [--log-file=<var>filename</var>]
     [-g] [--debug]
     [-E] [--embedded]
     [-l] [--no-line-convert]
     [-c] [--line-convert-all]
     [-s<var>classname</var>] [--super=<var>classname</var>]
     [-r<var>filename</var>] [--runtime=<var>filename</var>]
     [-a] [--no-omit-actions]
     [-C] [--check-only]
     [-S] [--output-status]
     [--version] [--copyright] [--help] <var>grammerfile</var>
</p>

<dl>
<dt><var>grammerfile</var>
<dd>
Raccの文法ファイルを指定します。拡張子には特に制限はありません。

<dt>-o<var>outfile</var>, --output-file=<var>outfile</var>
<dd>
作成するクラスをかきこむファイル名を指定します。デフォルトは<filename>.tab.rbです。

<dt>-e<var>rubypath</var>, --executable=<var>rubypath</var>
<dd>
実行可能ファイルを生成します。<var>rubypath</var>は Ruby 本体のパスです。
<var>rubypath</var>を単に 'ruby' にした時には Racc が動作している
Ruby のパスを使用します。

<dt>-v, --verbose
<dd>
ファイル "filename".output に詳細な解析情報を出力します。

<dt>-O<var>filename</var>, --log-file=<var>filename</var>
<dd>
-v オプションをつけた時に生成するログファイルの名前を
<var>filename</var> に変更します。デフォルトは "filename".output です。

<dt>-g, --debug
<dd>
出力するコードにデバッグ用コードを加えます。-g をつけて生成したパーサで
@yydebug を true にセットすると、デバッグ用のコードが出力されます。<br>
-g をつけるだけでは何もおこりませんので注意してください。

<dt>-E, --embedded
<dd>
ランタイムルーチンをすべて含んだコードを生成します。
つまり、このオプションをつけて生成したコードは Ruby さえあれば動きます。

<dt>-l, --no-line-convert
<dd>
Ruby では例外が発生した時のファイル名や行番号を表示してくれますが、
Racc の生成したパーサは、デフォルトではこの場合のファイル名・行番号を
文法ファイルでのものに置きかえます。このフラグはその機能をオフにします。
<p>
ruby 1.4.3 以前のバージョンではバグのために定数の参照に失敗する
場合があるので、定数参照に関してなにかおかしいことがおこったらこのフラグを
試してみてください。

<dt>-c, --line-convert-all
<dd>
アクションと inner に加え header footer の行番号も変換します。
header と footer がつながっているような場合には使わないでください。

<dt>-s<var>classname</var>, --super=<var>classname</var>
<dd>
パーサのスーパークラスを Racc::Parser から <var>classname</var> に
変更します。

<dt>-r<var>filename</var>, --runtime=<var>filename</var>
<dd>
require あるいは埋めこむランタイムファイルを racc/parser から
<var>filename</var>に変更します。

<dt>-a, --no-omit-actions
<dd>
全てのアクションに対応するメソッド定義と呼び出しを行います。
例えアクションが省略されていても空のメソッドを生成します。

<dt>-C, --check-only
<dd>
(文法ファイルの)文法のチェックだけをして終了します。

<dt>-S, --output-status
<dd>
進行状況を逐一報告します。

<dt>--version
<dd>
Racc のバージョンを出力して終了します。

<dt>--copyright
<dd>
著作権表示を出力して終了します。

<dt>-h, --help
<dd>
オプションの簡単な説明を出力して終了します。

</dl>

<% footer 1999 %>
. file grammer.html -----------------------------------------------------
<% header 'Grammer Reference' %>

<h1>規則ファイル文法リファレンス</h1>

<hr>

<h2>文法に関する前バージョンとの非互換</h2>
<ul>
<li>(1.2.5) ユーザーコードを連結する時、外部ファイルよりも
            埋めこんであるコードを先に連結します。
<li>(1.1.6) 新しいディレクティブ options が追加されました。
<li>(1.1.5) 予約語 token の意味が変更になりました。
<li>(0.14) ルールの最後のセミコロンが省略可能になりました。
           また、token prechigh などが予約語でなくなりました。
<li>(10.2) prepare が header に driver が footer になりました。
           今はそのままでも使えますが、2.0 からは対応しません。
<li>(0.10) class に対応する end がなくなりました。
<li>(0.9) ダサダサのピリオド方式をやめて { と } で囲むようにしました。
</ul>


<h2><a name="whole">全体の構造</a></h2>

<p>
トップレベルは、規則部とユーザーコード部に分けられます。
ユーザーコード部はクラス定義の後に来なければいけません。


<h3><a name="comment">コメント</a></h3>

<p>
文法ファイルには、一部例外を除いて、ほとんどどこにでもコメントを
書くことができます。コメントは、Rubyの #.....(行末) スタイルと、
Cの /*......*/ スタイルを使うことができます。


<h3><a name="class">規則部</a></h3>

<p>
規則部は以下のような形をしています。
<pre>

    class クラス名 [< スーパークラス]
      [演算子順位]
      [トークン宣言]
      [オプション]
      [トークンシンボル値おきかえ]
      [スタート規則]
    rule
      文法記述
    end

</pre>
"クラス名"はここで定義するパーサクラスの名前です。
これはそのままRubyのクラス名になります。

<p>
また M::C のように「::」を使った名前を使うと、クラス定義を
その module にネストさせます。つまり class M::C ならば
<pre>

module M
  class C < Racc::Parser
    いろいろ
  end
end

</pre>
のようになります。

<p>
さらに Ruby と同じ構文でスーパークラスを指定できます。
ただしこの指定をするとパーサの動作に重大な影響を与えるので、
特に必要がない限り指定してはいけません。


<h4><a name="grammer">文法の記述</a></h4>

<p>
racc で生成するパーサが理解できる文法を記述します。
文法は、予約語 rule と end の間に、以下のような書式で書きます。
<pre>

      トークン: トークンの並び アクション

      トークン: トークンの並び アクション
              | トークンの並び アクション
              | トークンの並び アクション
                  (必要なだけ同じようにつづける)

</pre>
アクションは { } で囲みます。ただしまだ対応が不十分なので、
中ではヒアドキュメントが使えません。コメントは # タイプのみです。
(本当は'}'がはいってなければどれも大丈夫ですが、やらないほうが無難)。<br>
また、アクションは省略できます。
省略すると、デフォルトの val[0] が返り値になります。
ちなみに、省略するほうがやや高速です。

<p>
左辺の値($$)は、オプションによって返し方がかわります。まずデフォルトでは
ローカル変数 result (そのデフォルト値は val[0])が 左辺値を表し、アクション
ブロックを抜けた時の result の値が左辺値になります。または明示的に return
で返した場合もこの値になります。一方、options で no_result_var を指定すると
左辺値はアクションブロックの最後の文の値になります (Rubyと同じ)。以下に
文法記述の全体の例をしめします。
<pre>

rule

  goal: def ruls source
        {
          result = val
        }

  def : /* none */
        {
          result = []
        }
      | def startdesig
        {
          result[0] = val[1]
        }
      | def
          precrule   # これは上の行の続きです。
        {
          result[1] = val[1]
        }
(略)
end  # endで規則部終了

</pre>
アクション内では、いくつか特別な意味をもった変数が使えます。
そのような変数には以下のものがあります。括弧の中は yacc での表記です。

<dl>
<dt>result ($$)
<dd>
左辺の値。初期値は val[0] です。

<dt>val ($1,$2,$3…)
<dd>
右辺の値の配列。Rubyの配列なので当然インデックスはゼロから始まります。
この配列は毎回作られるので変更しても構いません。

<dt>_values (...,$-2,$-1,$0)
<dd>
値スタック。
この変数の意味がわかる人以外は<em>絶対に</em>変更してはいけません。

</dl>

<p>
また特殊なアクションとして埋めこみアクションというものがあります。
埋めこみアクションはトークン列の途中の好きなところに記述することが
できるアクションです。以下は埋めこみアクションの例です。
<pre>

target: A B { puts 'test test' } C D { normal action };

</pre>
このように記述すると A B を検出した時点で puts が実行されます。
また、埋めこみアクションはそれ自体が値を持ちます。つまり、以下の例において
<pre>

target: A { result = 1 } B { p val[1] };

</pre>
p val[1] は埋めこみアクションの値 1 を表示します。B の値ではありません。

<p>
意味的には、埋めこみアクションは空の規則を持つ非終端記号を追加することと
全く同じ働きをします。つまり、上の例は次のコードと全く同じ意味です。
<pre>

target  : A nonterm B { p val[1] };
nonterm : /* 空の規則 */ { result = 1 };

</pre>


<h4><a name="prec">演算子優先順位</a></h4>

<p>
あるトークン上でシフト・還元衝突がおこったとき、そのトークンに
演算子優先順位が設定してあると、衝突を解消できる場合があります。
そのようなものとして特に有名なのは数式の演算子と if...else 構文です。

<p>
優先順位で解決できる文法は、うまく文法をくみかえてやれば
優先順位なしでも同じ効果を得ることができます。
しかしたいていの場合は、優先順位を設定して解決するほうが文法が簡単になります。

<p>
シフト・還元衝突がおこったとき、Racc はまずその規則に順位が設定されているか調べます。
規則の順位は、その規則で一番うしろにある終端トークンの優先順位です。たとえば、
<pre>

      target: TERM_A nonterm_a TERM_B nonterm_b ;

</pre>
のような規則の順位はTERM_Bの優先順位になります。もしTERM_Bに優先順位が設定されて
いなかったら、優先順位で衝突を解決することはできないと判断し、
「Shift/Reduce conflict」を報告します。

<p>
演算子優先順位は、つぎのように書きます。<br>
prechigh に近いほうが、順位の「高い」トークンです。上下をまるごとさかさまにして、
preclow...prechigh の順番に書くこともできます。
<pre>

    prechigh
      nonassoc PLUSPLUS
      left     MULTI DEVIDE
      left     PLUS MINUS
      right    '='
    preclow

</pre>
left などは必ず行の最初の単語でなければいけません。<br>
left right nonassoc はそれぞれ「右結合」「左結合」「結合しない」をあらわします。

<p>
通常は、還元する規則の最後のトークンが順位を決めますが、
ある規則に限って順位をあげたいときがあります。yacc で言えば %prec です。
たとえば、符号反転のマイナスは引き算のマイナスより順位を高くしないといけません。
<pre>

    prechigh
      nonassoc UMINUS
      left '*' '/'
      left '+' '-'
    preclow
(略)
    exp: exp '*' exp
       | exp '-' exp
       | '-' exp     = UMINUS    # 順位を上げる

</pre>
このように記述すると、'-' exp の規則の順位が UMINUS の順位になります。
こうすることで符号反転の '-' は '*' よりも順位が高くなるので、
意図どおりになります。


<h4><a name="token">トークン宣言</a></h4>
<p>
トークン(終端記号)のつづりを間違えるというのはよくあることですが、
発見するのはなかなか難しいものです。1.1.5 からはトークンを明示的に
宣言することで、宣言にないトークン/宣言にだけあるトークンに対して
警告が出るようになりました。yacc の %token と似ていますが最大の違いは
racc では必須ではなく、しかもエラーにならず警告だけ、という点です。<br>
トークン宣言は以下のように書きます。
<pre>

    token THIS_IS_TOKEN AND_IS_THIS
          ALSO_THIS_IS AGAIN_AND_AGAIN

</pre>
トークンのリストを複数行にわたって書けることに注目してください。
また Racc では一般に「予約語」は行の先頭に来た時だけ予約語とみなされるので
prechigh などもシンボルとして使えます。(ただし end だけはだめです)


<h4>オプション</h4>
<p>
racc のデフォルトのコマンドラインオプションをファイル中に
記述することができます。
<pre>

    options オプション オプション …

</pre>
現在使えるのは
<dl>
<dt>omit_action_call <dd>空のアクション呼び出しを省略するか
<dt>result_var       <dd>変数 result を使うか
</dl>
です。それぞれ no_ を頭につけることで意味を反転できます。


<h4><a name="convert">トークンシンボル値の変更</a></h4>
<p>
トークンシンボルを表す値は、デフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの(RULEとかXENDとか)<br>
    →その名前の文字列を intern して得られるシンボル(1.4 では Fixnum)
<li>引用符でかこまれているもの(':'とか'.'とか)<br>
    →その文字列そのまま
</ul>

<p>
となっていますが、たとえば他の形式のスキャナがすでに存在する場合などは、
これにあわせなければならず、このままでは不便です。このような場合には、
convert 節を加えることで、トークンシンボルを表す値を変えることができます。
以下がその例です。
<pre>

    convert
      PLUS 'PlusClass'      # --> PlusClass
      MIN  'MinusClass'     # --> MinusClass
    end

</pre>
デフォルトでは、トークンシンボルPLUSに対してはトークンシンボル値は:PLUSですが、
上のような記述がある場合は、PlusClassになります。
変換後の値は false、nil 以外ならなんでも使えます。

<p>
変換後の値として文字列を使うときは、次のように引用符を重ねる必要があります。
<pre>

    convert
      PLUS '"plus"'       # --> "plus"
    end

</pre>

<p>
また、「'」を使っても生成された Ruby のコード上では「"」になるので注意してください。
バックスラッシュによるクオートは有効ですが、バックスラッシュは消えずにそのまま
残ります。<em>これは仕様です。バグではありません。</em>
<pre>

      PLUS '"plus\n"'          # --> "plus\n"
      MIN  "\"minus#{val}\""   # --> \"minus#{val}\"

</pre>


<h4><a name="start">スタート規則</a></h4>

<p>
パーサをつくるためには、どの規則が「最初の」規則か、ということを Racc におしえて
やらなければいけません。それを明示的に書くのがスタート規則です。スタート規則は
次のように書きます。
<pre>

      start real_target

</pre>
start は行の最初にこなければいけません。<br>
このように書くと、最初にある real_target の規則をスタート規則として使います。
省略した場合は、最初の規則がスタート規則になります。
普通は、最初の規則を一番上にかくほうが書きやすく、わかりやすくなりますから、
この記法はあまりつかう必要はないでしょう。


<h3><a name="usercode">ユーザーコード部</a></h3>

<p>
ユーザーコードは、パーサクラスが書きこまれるファイルに、
アクションの他にもコードを含めたい時に使います。このようなものは
書きこまれる場所に応じて三つ存在し、パーサクラスの定義の前が
header、クラスの定義中(の冒頭)が inner、定義の後が footer です。
ユーザコードとして書いたものは全く手を加えずにそのまま連結されます。

<p>
ユーザーコード部の書式は以下の通りです。
<pre>

---- ユーザーコードの識別子
  ruby の文
  ruby の文
  ruby の文

---- 次のユーザーコードの識別子
  ruby の文
     :

</pre>
行の先頭から四つ以上連続した「- (マイナス)」があるとユーザーコードと
みなされます。識別子は一つの単語で、そのあとには「=」以外なら何を
書いてもかまいません。

<p>
また、次のような文で外部ファイルをユーザーコードとしてインクルード
することもできます。
<pre>

---- 識別子 = ファイル名 ファイル名 ファイル名 .....

</pre>
以下はこの記述を使った例です。
<pre>

---- footer = init.rb err.rb run.rb

print "this line is added, too\n"

</pre>
ここでは init.rb err.rb run.rb の三つを footer コードとして指定しています。
こうするとまず ---- のある行の下に書いたもの(printのある行など)が連結され、
その後にこれら三つのファイルの中身が連結されます(この順番は 1.2.5 から)。
さきほど ---- のある行の識別子のあとはなにを書いてもいいと言いましたが、
外部ファイルを指定する場合はなにも書くことができません。コメントもだめです。
正確にファイル名だけをならべて書いてください。

<p>
またほとんどの人には関係ないことですが、いちおうつけくわえます。
上に書いたような順番からすると、最終的な全体像は次のようになります。
<pre>

# header
# 外部 header
class MyParser < Racc::Parser
  # inner
  # 外部 inner
  # パーサコア
end
# footer
# 外部 footer

</pre>
ここから、もし header と footer を使ってパーサをモジュールの中に
ネストさせていてしかも外部 header がそのモジュールの外で定義
されるべきである場合、問題が起きます。具体的には以下のような場合です。
<pre>
(mondai.y)

class MyParser
rule
  いろいろする
end
---- header = mypar.head
module MyMod
---- footer
end


(mypar.head)

module MyMod
  class HelperClass
    いろいろする
  end
end

</pre>
この場合、mypar.head が header の module MyMod の後に来てしまうので
HelperClass は ::MyMod::MyMod::HelperClass になってしまいます。
これはおそらく意図と違うはずです。

<% footer 1999 %>
. file parser.html ------------------------------------------------
<% header 'Parser' %>

<h1>parser.rb</h1>

<hr>

<h2><a name="parser">Racc::Parserクラス</a></h2>

<p>
Racc の生成するパーサはすべて Parser クラスを継承します。
Parser クラスにはパース中に使用するメソッドがいくつかあり、
そのようなメソッドをオーバーロードすると、パーサの初期化などができます。
逆に言うと、これらのメソッドを変に再定義すると挙動がおかしく
なるわけですから注意してください。


<h3>ファイル</h3>
<p>
racc/parser.rb

<h3>スーパークラス</h3>
<p>
Object


<h3>定数</h3>
<p>
プリフィックス "Racc_" がついた定数はパーサの予約定数です。
そのような定数は使わないでください。動作不可能になります。

<h3>メソッド</h3>
<dl>
<dt><a name="do_parse">do_parse</a>
<dd>
このメソッドを呼ぶことによってパースが開始します。また、
トークンが必要になった時は next_token を呼び出します。

<dt><a name="next_token">next_token</a> [abstract]
<dd>
パーサが次のトークンを読みこむ時に使います。[トークンシンボル,その値]
の形式の配列を返してください。トークンシンボルの値は、デフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの<br>
    →その名前の文字列を intern して得られるシンボル(たとえば:ATOM)
<li>引用符でかこまれているもの<br>
    →その文字列そのまま(たとえば、'=')
</ul>
です。これを変更する方法については、
<a href="grammer.html#token">文法リファレンス</a>を参照してください。
<p>
また、もう送るシンボルがなくなったときには、[false,なにか] を返してください。
これを忘れるとわけのわからないパースエラーになります。(一回送れば十分です)
<p>
また、このメソッドは抽象メソッドなので、do_parse を使う場合は
<em>必ず</em>下位クラスで再定義する必要があります。定義しないまま
パースを始めると例外が発生します。

<dt><a name="yyparse">yyparse( recv, mid )</a>
<dd>
このメソッドを呼ぶことによってパースが開始します。
このメソッドでは始めてトークンが必要になった時点で recv に対して
mid メソッドを呼び出し、そのブロックからトークンを得ます。
つまり、recv#mid というメソッドを用意して yyparse(recv,mid) とすれば
recv#mid からトークンを yield して渡すことができます。yield するのは
next_token と同じ形式の [記号, 値] です。ちなみにこれは Ruby の特性から
「yield 記号, 値」と同じです。
<p>
少し注意が必要なのは、recv#mid が呼び出されるのは始めてトークンが
必要になった時点であるということで、つまりその時点でもうパースが
進行中だということです。よって、recv#mid の最初でパースの初期化を
するとうまくいかない場合があります。また false を渡したらそれ以上は
yield しないでください。その場合には例外が発生します。<br>
それから、recv#mid では必ず yield してください。しない場合は
どうなっても知りません。

<dt>on_error( err_tok, err_val, _values )
<dd>
パースエラーを検出したとき、よびだされます(yyerror)。
メッセージを出すなり、例外を発生するなりしてください。
このメソッドからもどったあとは、パーサはエラー回復モードに移行します。<br>
引数は、err_tok がパースエラーをおこしたシンボルトークン(内部表現の整数)、
err_val がその値、_values はその時点の値スタックです。
<p>
デフォルトでは、例外 ParseError を発生します。

<dt>yyerror
<dd>
アクション中で呼びだすとエラー回復モードに入ります。
このとき on_error は呼ばれません。

<dt>yyerrok
<dd>
アクション中で呼びだすとエラー回復モードから復帰します。

<dt>yyaccept
<dd>
このメソッドを呼びだすとすぐに値スタックの先頭の値を返して
do_parse を抜けます。

</dl>


<% footer 1999 %>
. file debug.html ----------------------------------------------------------
<% header 'Debug' %>

<h1>デバッグ情報</h1>

<hr>
<p>
ここでは、Racc を使っていくうえで遭遇しそうなバグについて書きます。
ただ、徐々に減ってはいますが、現時点ではまだまだ racc 自身のバグの可能性も高いです。
もし「これはバグに違いない！」というエラーに遭遇したらメールをください。
そのときは、規則ファイルなどもつけてくださるようお願いします。

<p>
また、racc コマンドに -v オプションをつけてコンパイルすると、内部情報が
"ファイル名.output" に出力されます。このファイルの情報はデバッグには
必須ですから、デバッグ中は常に -vg をつけてコンパイルすることをおすすめします。


<h2>インストールできないんだけど。</h2>
<p>
どうしたらいいんでしょうねえ。

<h2>規則ファイルがパースエラーになるよう。</h2>
<p>
エラーメッセージに出てる行に文法の間違いがあります。
どこが間違ってるかは じっと見て考えましょう。

<h2>衝突</h2>
<p>
一番ありがちな問題は、衝突でしょうか。
衝突があると、racc がコンパイル後に「衝突がある」とメッセージを
出すのですぐわかります。.output ファイルにはさらに詳しい情報が出力されます。
それをどうやって解決するか、とかそういうことに関しては、それなりの本を読んでください。
とてもここに書けるような単純な話ではありません。例えば O'Reilly の「lex & yacc」。

<h2>next_token に関して</h2>
<p>
いまだ自分でも忘れることが多いのが、「スキャンが終了したら[false,なにか]を送る」
ということです。0.10.2 からは一回送ったらもうそれ以上は next_token を呼びません。

<h2>デバッグ出力</h2>
<p>
racc に -g オプションをつけてコンパイルすると、デバッグ用のコードが付加されます。
ここで、パーサクラスのインスタンス変数 @yydebug を true にしておいてから
do_parse を呼ぶと、デバッグ用メッセージを出力します。パーサがシフト/還元していく
様子が直接見えますので、完全に現在の状態を把握できます。
どこで止まっているのかがわかればあとは直すだけ。

<hr>
<h2>yaccとの文法の違い</h2>


<h3>定義部</h3>
<p>
yacc では % がいっぱいでてきますが、racc では % は出てきません。
それから、C では変数に型があるためにそれを指定する文法がたくさんありますが、
Ruby は型無しですからそっち関係のものはなくなっています。
<p>
yacc では終端記号(トークン)を事前に指定しますが、
Racc では左辺にこないものを自動的に終端記号とみなします。
ということはつまり、非終端記号 nonterm を noterm と書きまちがったがために、
それが終端記号とみなされて、妙なことになる可能性があるということです。
これを防止するためには、.output ファイルを出力させて、変なものが終端記号になって
いないか(もちろんその逆も)チェックするとよいでしょう。
<p>
バージョン 0.10 からは全体の構造が class ... rule ... end のようになりました。


<h3>規則部</h3>
<p>
規則部分は yacc とほぼ同じです。
<p>
%prec は = をつかいます。
<p>
yacc ではコメントは /* ... */ だけですが racc では #...(行末) もあります。


<h3>ユーザーコード部</h3>
<p>
yacc ではユーザーコードを分類する必要はありませんが、racc ではパーサがクラスなので、
配置する場所によってユーザーコードを分類しています。ユーザーコードの指定方法も
0.9 で ---- を使うように大きく変わったので気をつけてください。

<% footer 1999 %>
. file changes.html ----------------------------------------------------------
<% header 'Change Log' %>

<h1>変更履歴</h1>

<hr>
<h2>1.3.4 (2001-01-11)</h2>
<p>
<ul>
<li>cparse: シンボルのタイプチェックを入れた
<li>cparse: depend を消した
<li>cparse: rb_iterate 中の GC で落ちるバグを修正
</ul>

<h2>1.3.3 (2000-12-25)</h2>
<p>
<ul>
<li>ジェネレータに致命的なバグ。1.3.1 から混入 (format.rb)
<li>racc --runtime-version
</ul>

<h2>1.3.2 (2000-12-21)</h2>
<p>
<ul>
<li>-E が失敗するのを直した
<li>再度 strscan を同梱 (y2racc/racc2y に必要)
</ul>

<h2>1.3.1 (2000-12-17)</h2>
<p>
<ul>
<li>正規表現の繰り返し指定の上限を動的に決定する (RE_DUP_MAX)
<li>パースルーチンが常に Ruby 版になっていた (消し忘れ。)
</ul>

<h2>1.3.0 (2000-11-30)</h2>
<p>
<ul>
<li>スキャナから yield でトークンを渡せるようになった
</ul>

<h2>1.2.6 (2000-11-28)</h2>
<p>
<ul>
<li>class M::C を許した
</ul>

<h2>1.2.5 (2000-11-20)</h2>
<p>
<ul>
<li>オプションに大変動。非互換オプションは -h -f -p -i -n -c -A
<li>ロングオプションをサポート
<li>y2racc, racc2y はデフォルトでアクションを残すようにした
</ul>

<h2>1.2.4 (2000-09-13)</h2>
<p>
<ul>
<li>インストーラとドキュメントを更新
</ul>

<h2>1.2.3 (2000-08-14)</h2>
<p>
<ul>
<li>使われない規則と非終端記号を出力 (強力版)
<li>S/R conflict の時 nonassoc で解決するならばエラー
</ul>

<h2>1.2.2 (2000-08-12)</h2>
<p>
<ul>
<li>内部の変更
</ul>

<h2>1.2.1 (2000-08-05)</h2>
<p>
<ul>
<li>yacc との変換コマンド racc2y・y2racc を添付
</ul>

<h2>1.2.0 (2000-08-02)</h2>
<p>
<ul>
<li>先読みアルゴリズムを bison のものに変更
</ul>

<h2>1.1.6 (2000-07-25)</h2>
<p>
<ul>
<li>新たなキーワード options とその引数 no_result_var
</ul>

<h2>1.1.5 (2000-07-21)</h2>
<p>
<ul>
<li>[重要] token を convert に変更
<li>「新たな」キーワード token (終端記号の宣言)
</ul>

<h2>1.1.4 (2000-07-13)</h2>
<p>
<ul>
<li>インストーラをアップデート。
    cparse を選択インストールできるようにした
<li>サンプルがバグってた
</ul>

<h2>1.1.3 (2000-06-30)</h2>
<p>
<ul>
<li>空アクションの呼び出しを省略しないようにするオプション -a
</ul>

<h2>1.1.2 (2000-06-29)</h2>
<p>
<ul>
<li>スキャナで strscan を使わないようにした
<li>ScanError -&gt; Racc::ScanError, ParseError -&gt; Racc::ParseError
<li>エラーメッセージを強化
</ul>

<h2>1.1.1 (2000-06-15)</h2>
<p>
<ul>
<li>requireミス (thanks Toshさん)
<li>-v をつけるとconflictが報告されなくなっていた
</ul>

<h2>1.1.0 (2000-06-12)</h2>
<p>
<ul>
<li>新しい 状態遷移表生成アルゴリズム
</ul>

<hr>
<h2>1.0.4 (2000-06-04)</h2>
<p>
<ul>
<li>S/R conflict がおきると .output 出力で落ちるバグ修正 (Tosh さんの報告)
<li>使われない非終端記号・規則を表示
</ul>

<h2>1.0.3 (2000-06-03)</h2>
<p>
<ul>
<li>filter -&gt; collect!
</ul>

<h2>1.0.2 (2000-05-16)</h2>
<p>
<ul>
<li>インストーラをアップデート
</ul>

<h2>1.0.1 (2000-05-12)</h2>
<p>
<ul>
<li>state.rb:  先読みルーチンをちょっとだけ高速化 && 追加デバッグ
<li>コードを整理した。著作権表示全体を全部のファイルにつけた。
<li>amstd アップデート (1.7.0)
</ul>

<h2>1.0.0 (2000-05-06)</h2>
<p>
<ul>
<li>バージョン 1.0
</ul>

<hr>
<h2>0.14.6 (2000-05-05)</h2>
<p>
<ul>
<li>デバッグ出力を詳細にした
</ul>

<h2>0.14.5 (2000-05-01)</h2>
<p>
<ul>
<li>インストーラを ruby 1.4.4 系の新しいパスに対応させた
    (thanks rubykitch さん、Tosh さん)
</ul>

<h2>0.14.4 (2000-04-09)</h2>
<p>
<ul>
<li>パーサの定数を削減(Racc_arg にまとめた)
<li>state 生成を微妙に高速化(コアを文字列に変換)
</ul>

<h2>0.14.3 (2000-04-04)</h2>
<p>
<ul>
<li>cparse の SYM2ID と ID2SYM のチェックを分離 (thanks 小松さん)
</ul>

<h2>0.14.2 (2000-04-03)</h2>
<p>
<ul>
<li>一行目の class がパースエラーになっていた (thanks 和田さん)
<li>新しいフラグ racc -V
</ul>

<h2>0.14.1 (2000-03-31)</h2>
<p>
<ul>
<li>インストーラで Ruby のパスを指定したときには
    system に与えるRubyのパスも変えるようにした (thanks Toshさん)
</ul>

<h2>0.14.0 (2000-03-21)</h2>
<p>
<ul>
<li>高速テーブルを実装
<li>一時的にファイル名/行番号の変換をやめた(Rubyのバグのため。)
</ul>

<hr>
<h2>0.13.1 (2000-03-21)</h2>
<p>
<ul>
<li>--version --copyright などがうまく働いてなかった (thanks ふなばさん)
</ul>

<h2>0.13.0 (2000-03-20)</h2>
<p>
<ul>
<li>yyerror/yyerrok/yyaccept を実装
</ul>

<hr>
<h2>0.12.2 (2000-03-19)</h2>
<p>
<ul>
<li>-E フラグがバグってた (thanks ふなばさん)
</ul>

<h2>0.12.1 (2000-03-16)</h2>
<p>
<ul>
<li>デフォルトアクションの決め方をちょっと修正(元に戻しただけ)
</ul>

<h2>0.12.0 (2000-03-15)</h2>
<p>
<ul>
<li>別のバグどころではなかった。先読みルーチンが LALR になっていない。
    四日がかりでようやく修正した。
<li>完全な LALR を実装したら遅くなったので SLR も併用するようにした。効果絶大。
</ul>

<hr>
<h2>0.11.3 (2000-03-09)</h2>
<p>
<ul>
<li>状態遷移表生成のバグの修正がまだ甘かった。さらに別のバグもあるようだ。
</ul>

<h2>0.11.2 (2000-03-09)</h2>
<p>
<ul>
<li>状態遷移表生成部に(最後(になってほしい)の)バグ。
    先読みコードが再帰した場合にトークンが少なくなってしまっていた
<li>cparse が Symbol に対応できてなかった
</ul>

<h2>0.11.1 (2000-03-08)</h2>
<p>
<ul>
<li>ruby 1.5 の Symbol に対応
<li>strscan を最新に
</ul>

<h2>0.11.0 (2000-02-19)</h2>
<p>
<ul>
<li>例外のとき、元のファイルの行番号が出るようにした
</ul>

<hr>
<h2>0.10.9 (2000-01-19)</h2>
<p>
<ul>
<li>セットアップ方法など細かな変更
</ul>

<h2>0.10.8 (2000-01-03)</h2>
<p>
<ul>
<li>忘れてしまったけどたしかインストーラ関係の修正
<li>(1/17 re-packed) ドキュメントの追加と修正
</ul>

<h2>0.10.7 (2000-01-03)</h2>
<p>
Thanks 新井さん
<ul>
<li>setup.rb compile.rb amstd/inst などのバグ修正
</ul>

<h2>0.10.6 (1999-12-24)</h2>
<p>
<ul>
<li>racc -e ruby でデフォルトパスを使用
<li>空のアクションの呼びだしは省略するようにした
</ul>

<h2>0.10.5 (1999-12-21)</h2>
<p>
thanks Toshさん
<ul>
<li>埋めこみアクションの実装がすさまじくバグってた
<li>setup.rb が inst.rb の変化に追従してなかった
<li>calc.y calc2.y を 0.10 用に修正
</ul>

<h2>0.10.4 (1999-12-19)</h2>
<p>
<ul>
<li>エラー回復モードを実装
<li>racc -E で単体で動作するパーザを生成
<li>Racc は class から module になった
</ul>

<h2>0.10.3 (1999-12-01)</h2>
<p>
<ul>
<li>埋めこみアクションをサポート
<li>.output の出力内容にバグがあったのを修正
</ul>

<h2>0.10.2 (1999-11-27)</h2>
<p>
<ul>
<li>ドキュメントの訂正と更新
<li>libracc.rb を分割
</ul>

<h2>0.10.1 (1999-11-19)</h2>
<p>
<ul>
<li>C でランタイムを書きなおした
<li>next_token が false を返したらもう読みこまない
<li>アクションがトークンによらず決まるときは next_token を呼ばない
<li>$end 廃止
<li>LALRactionTable
</ul>

<h2>0.10.0 (1999-11-06)</h2>
<p>
<ul>
<li>next_* を next_token に一本化、peep_token 廃止
<li>@__debug__ -&lt; @yydebug など変数名を大幅変更
<li>文法ファイルの構造が class...rule...end に変わった
<li>コアのコードを一新、高速化
<li>strscan を併合
<li>ライブラリを racc/ ディレクトリに移動
</ul>

<hr>
<h2>0.9.5 (1999-10-03)</h2>
<p>
thanks > Toshさん
<ul>
<li>0.9.4 の変更がすごくバグってた
<li>$end が通らなかったのを修正
<li>__show_stack__ の引数が違ってた
</ul>

<h2>0.9.4 (1999-09-??)</h2>
<p>
<ul>
<li>Parser::Reporter をなくしてメソッドに戻した
<li>d.format.rb を再編成
</ul>

<h2>0.9.3 (1999-09-03)</h2>
<p>
<ul>
<li>racc.rb -> racc
</ul>

<h2>0.9.2 (1999-06-26)</h2>
<p>
<ul>
<li>strscan使用
</ul>

<h2>0.9.1 (1999-06-08)</h2>
<p>
<ul>
<li>アクション中の正規表現に対応 ( /= にも注意だ)
<li>アクション中の # コメントに対応
</ul>

<h2>0.9.0 (1999-06-03)</h2>
<p>
<ul>
<li>アクションを { } 形式にした
<li>ユーザーコードを '----' を使う形式にした
</ul>


<hr>

<h2>0.8.11 (?)</h2>
<p>
<ul>
<li>-g 出力をわかりやすくした
</ul>

<h2>0.8.10 (?)</h2>
<p>
<ul>
<li>アクションからreturnできるようにした
</ul>

<h2>0.8.9 (1999-03-21)</h2>
<p>
<ul>
<li>-g + @__debug__をつかったデバッグメッセージ操作
<li>エラー発生時のバグを修正
<li>TOKEN_TO_S_TABLEを付加するようにした
</ul>

<h2>0.8.8 (1999-03-20)</h2>
<p>
<ul>
<li>100倍程度の高速化
<li>defaultトークンを加えた
<li>デバッグ用ソースを出力するオプション-gをくわえた
<li>user_initializeを廃止し、普通にinitializeを使えるようにした
<li>parse_initialize/finalize,parseメソッドを廃止
<li>next_token,next_value,peep_tokenのデフォルトを廃止
<li>%precと同等の機能を加えた
</ul>

<h2>0.8.7 (1999-03-01)</h2>
<p>
<ul>
<li>内部構造が大幅に変化
<li>マニュアルがHTMLになった
</ul>

<h2>0.8.0 (1999-01-16)</h2>
<p>
なぜいきなり 0.8 ？？？
<ul>
<li>文法がブロック型に変化
</ul>

<h2>0.5.0 (1999-01-07)</h2>
<p>
<ul>
<li>演算子優先順位が実装されたようだ
<li>スタート規則が実装されたようだ
<li>トークン値の置換が実装されたようだ(後に致命的なバグ発見)
</ul>

<h2>0.1.0 (1999-01-01)</h2>
<p>
とにかく動くようになった

<% footer 1999 %>
