. file index.html -------------------------------------------------------
. header Racc User Manual

<h1>Racc user manual</h1>

updated for version 0.10.8

<p>
Raccは文法規則からRubyのパーサクラスを生成するパーサジェネレータです。
パーサ生成アルゴリズムとして、yacc などと同じLALR(1)を使用しています。

<ul>
<li><a href="usage.html">Raccの使い方</a>
<li><a href="command.html">racc コマンドリファレンス</a>
<li><a href="grammer.html">規則ファイル文法リファレンス</a>
<li><a href="parser.html">Parserクラスリファレンス</a>
<li><a href="debug.html">デバッグ情報</a>
<li><a href="scan.html">スキャナ作成ライブラリ</a>
<li><a href="changes.html">変更履歴</a>
</ul>

. footer
. file usage.html --------------------------------------------------------
. header Usage

<h1>Racc の使い方</h1>

<h2>ひとの作ったパーサを使う</h2>

<p>
もうすでに文法ファイルがある場合です。この場合は単にraccコマンドが使えればよく、
文法ファイルの書きかたを覚えたりする必要はありません。

<p>
文法ファイルの名前が parse.y と仮定すると、コマンドラインから以下のように
打ちこむことで、パーサを含んだファイルが得られます。
<pre>

$ racc parse.y

</pre>
生成されるファイルはデフォルトでは "ファイル名.tab.rb" になります。
これは -o オプションで変更できます。


<h2>自分でパーサを作る</h2>

<p>
自分でraccの文法ファイルを記述する場合です。
racc は yacc を知っていることを前提にしていますので、もし知らないのなら
先に yacc を勉強しましょう。いきなり racc を使うのは不可能です。(これは断言できます)

<h3>概観</h3>
<p>
yacc は yyparse(関数)を生成しますが、racc は yyparse に相当する do_parse
メソッドを持ったパーサクラスを生成します。
生成されるクラスは全て Racc::Parser の下位クラスで、規則ファイル中で指定します。
規則ファイルの文法の詳細は、<a href="grammer.html">文法リファレンス</a>を
参照してください。

<h3>規則ファイル</h3>
<p>
以下には規則ファイルの文法の概略だけ書いておきます。<br>
まずは、全体の概形です。
<pre>

class MyParser

rule
  target: exp ;
  exp: tok     { print val[0] }
     | exp tok { print val[1] };  # コメント
  tok: A | '+' | '-';             /* これもコメント */
end

</pre>
Rubyスクリプトのように class でクラス名を指定し、rule ... end の間に文法を記述します。
トークンは Ruby のローカル変数/定数として有効なものが使えます。
yacc だと終端記号を %token で指定する必要がありますが、racc ではそのような
指定は必要ありません。左辺に来ないトークンはすべて終端記号とみなされます。

<p>
アクションは、yacc と同じように規則のあとに { と } で囲んで指定します。
当然ながら、アクションはRubyの文で記述します。<br>
yacc での $$ は Racc ではローカル変数 result で、$1,$2... は配列 val です。
result は val[0]($1) の値に初期化され、アクションを抜けたときの result の値が
左辺値になります。Racc ではアクション中の return はアクションから抜けるだけで、
パーズ自体は終わりません。YYACCEPT のようなものもまだないので、
アクション中からパーズを終了するには catch か raise を使う以外にはありません。
YYACCEPT 相当の機能は将来には実装する予定です。

<p>
演算子の優先順位、スタートルールなどの yacc の一般的な機能も用意されています。
ただしこちらも少し文法が違います。

<p>
yacc では生成されたコードに直接転写されるコードがありました。Racc でも同じように、
ユーザ指定のコードが書けます。racc ではクラスを生成するので、クラス定義の前/中/後の
三個所があります。Racc ではそれを上から順番に header inner footer と呼んでいます。
0.10.1 までは prepare inner driver でしたがかっこわるいので変更しました。
ただし、互換性のため前のままでも使えるようになっています。

<h3>ユーザが用意すべきコード</h3>
<p>
inner では、Racc の yylex に相当するメソッド next_token を定義する必要があります。
このメソッドは、トークンシンボルとその値の二要素を持つ配列を返すようにします。
この配列を Racc が破壊することはありません。また、どこか他のところで使うことも
ありません。<br>
スキャンが終了して、もう送るものがない場合は [false,false] を返してください。
[false, false] を受けとったらそれ以上 next_token は呼びだされません。

<p>
LALR パーザは別に文字列処理にだけ使われるものではありませんが、実際問題として
パーザを作る場面ではたいてい文字列のスキャナとセットで使うことが多いでしょう。
Ruby ならスキャナくらい楽勝で作れますが、高速なスキャナとなると実は難しかったり
します。そこで、高速な<a href="scan.html">スキャナを作成するためのライブラリ</a>
が同梱されています。もし使えるようであればどんどん使ってください。

<p>
Racc には、error トークンを使ったエラー回復機能もあります。<br>
yyerror() は Racc では <a href="parser.html">Parser#on_error</a>で、
エラーがおきたトークンとその値、値スタックの 3 引数をとります。
on_error はデフォルトでは例外 ParseError を発生します。

<h3>パーザを生成する</h3>
<p>
これだけあればだいたい書けると思います。あとは、最初に示した方法でコンパイルし、
Rubyスクリプトを得ます。<br>
うまくいけば問題ないですが、大きいものだと最初からはうまくいかないでしょう。
racc に -g オプションをつけてコンパイルし、@yydebug を true にすると
デバッグ用の出力が得られます。また、-v オプションをつけると、
状態遷移表を読みやすい形で出力したファイル(.output)が得られます。
どちらもデバッグの参考になると思います。


<h2>作ったパーザを配布する</h2>
<p>
Racc の生成したパーザは動作時にランタイムルーチンが必要になります。
具体的には parser.rb と cparse.so それと amstd/ のスクリプトが少しです。
cparse.so は高速にパーズするための拡張モジュールで、amstd/ はユーティリティ、
parser.rb はそれらすべてのフロントエンドです。<br>
これらのファイルを自分でセットアップするのはなかなか面倒です。
Racc をユーザみんなにインストールしてもらうのも一つの手ですが、
これではユーザにとって不親切です。
そこで、Racc では回避策をふたつ用意しました。

<h3>ランタイム配布の自動化</h3>
<p>
ひとつめは、ランタイムとそのインストーラをまるごと自分のソフトのパッケージに
含めてしまうことです。方法は簡単で、Racc パッケージのトップディレクトリに
入って次のように起動します。
<pre>

ruby rtpack.rb TARGET/

</pre>
これで、ディレクトリ TARGET/ 以下に必要なファイルがインストールされます。
このとき、一度 TARGET/ 以下をクリアするので気をつけてください。

<p>
また、インストール時には、TARGET/ に移動して ruby setup.rb を実行すれば
ランタイムをインストールできます。

<p>
この方法だと、速度を保ったまま、パーザを配布できるのが利点です。

<h3>-E オブションを使う</h3>
<p>
racc に -E オプションをつけてコンパイルすると、必要なものを全部結合した
ファイルが得られます。これだとファイルはひとつだけなので扱いが楽です
(この形式のパーザが複数あったとしてもクラスやメソッドが衝突することは
ありません)。

<p>
この方法だと、特別なことはなにもする必要がないので、非常に扱いが楽です。
ただし、cparse.so が使えませんので、必然的に動作は Ruby スクリプトのみになり
速度は低下します。<br>
ただし、これも例外があって、配布先に既に Racc ランタイムがあるときは
自動的にそちらが使われます。


. footer
. file command.html -----------------------------------------------------------
. header racc command

<h1>Raccコマンドリファレンス</h1>

<hr>

<p align=justify>
  racc.rb [-vgE] [--version] [--help] [-o<var>outfile</var>] [-e<var>path</var>]
    [-n<var>classname</var>] [-h<var>header</var>] [-i<var>inner</var>]
    [-f<var>footer</var>] <var>filename</var>
</p>

<dl>
<dt><var>filename</var>
<dd>
Raccの文法ファイルを指定します。拡張子は好きなものにしてください。

<dt>-o<var>outfile</var>
<dd>
作成するクラスをかきこむファイル名を指定します。デフォルトは<filename>.tab.rbです。

<dt>-e<var>path</var>
<dd>
実行可能ファイルを生成します。<var>path</var>はRuby本体のパスです。
<var>path</var>を 'ruby' にすると Racc が動作している Ruby のパスを使用します。

<dt>-v
<dd>
verbose mode。"filename".outputファイルに詳細な解析情報を出力します。

<dt>-g
<dd>
出力するコードにデバッグ用コードを加えます。-g をつけて生成したパーサで
@yydebug を true にセットすると、デバッグ用のコードが出力されます。<br>
-g をつけるだけでは何もおこりませんので注意してください。

<dt>-E
<dd>
ランタイムルーチンをすべて含んだコードを生成します。
つまり、このオプションをつけて生成したコードは Ruby さえあれば動きます。

<dt>-n<var>classname</var>
<dd>
作成するクラスの名前を指定します。文法中の指定を上書きします。

<dt>-h<var>header</var>
<dd>
文法ファイル中の「header」コードのかわりに、指定したファイルの内容を
使ったソースコードを出力します。

<dt>-i<var>inner</var>
<dd>
文法ファイル中の「inner」コードのかわりに、指定したファイルの内容を使った
ソースコードを出力します。

<dt>-f<var>footer</var>
<dd>
文法ファイル中の「driver」コードのかわりに、指定したファイルの内容を使います。

<dt>-P
<dd>
実行段階ごとの所要時間を出力します。

<dt>--version
<dd>
Raccのバージョンを出力して終了します。

<dt>--help
<dd>
オプションの簡単な説明を出力して終了します。

</dl>

. footer
. file grammer.html -----------------------------------------------------
. header grammer

<h1>規則ファイル文法リファレンス</h1>

<hr>

<p>
これは暫定仕様です。未来には確実に変更されるので気をつけてください。<br>
バージョン 0.10.3 では埋めこみアクションをサポートしました。<br>
バージョン 0.10.2 では prepare が header に driver が footer になりました。
前のままでも使えますが将来は消えるかもしれません。<br>
バージョン 0.10 では class に対応する end がなくなり、
class...rule...end の形になりました。<br>
0.9 ではダサダサのピリオド方式をやめて { と } で囲むようにしました。


<h2><a name="whole">全体の構造</a></h2>

<p>
トップレベルは、規則部とユーザーコード部に分けられます。ユーザーコード部は
クラス定義の後に来なければいけません。


<h3><a name="comment">コメント</a></h3>

<p>
文法ファイルには、一部例外を除いて、ほとんどどこにでもコメントを
書くことができます。コメントは、Rubyの #.....(行末) スタイルと、
Cの /*......*/ スタイルを使うことができます。


<h3><a name="class">規則部</a></h3>

<p>
規則部は以下のような形をしています。
<pre>

    class クラス名
      [演算子順位]
      [スタート規則]
      [トークンシンボル値定義]
    rule
      文法記述
    end

</pre>
"クラス名"はここで定義するパーサクラスの名前です。
これはそのままRubyのクラス名になります。


<h4><a name="grammer">文法の記述</a></h4>

<p>
racc で生成するパーサが理解できる文法を記述します。
文法は、予約語 rule と end の間に、以下のような書式で書きます。
<pre>

      トークン: トークンの並び アクション ;

      トークン: トークンの並び アクション
              | トークンの並び アクション
              | トークンの並び アクション
              ;
                  (必要なだけ同じようにつづける)

</pre>
書式は yacc とほぼ同じです。ただし、セミコロンは必須です。アクションがあっても
省略してはいけません。

<p>
アクションは { } で囲みます。ただしまだ対応が不十分なので、
中では % 文字列やヒアドキュメントは使えません。コメントは # タイプのみ。
正規表現は // タイプのみです
(本当は'}'がはいってなければどれも大丈夫ですが、やらないほうが無難です)。<br>
また、アクションは省略してもかまいません。

<p>
右辺の返り値($$)は、アクションから出たときのローカル変数 result の値か、
もしくは明示的に return で返した値になります。また、result はアクション実行の前に
val[0]($1)に初期化されます。<br>
以下に文法記述の全体の例をしめします。
<pre>

rule

  goal: def ruls source
        {
          result = val
        }
      ;

  def : /* none */
        {
          result = []
        }
      | def startdesig
        {
          result[0] = val[1]
        }
      | def
          precrule   # これは上の行の続きです。
        {
          result[1] = val[1]
        }
      ;
(略)
end  # endで規則部終了

</pre>
アクション内では、いくつか特別な意味をもった変数が使えます。そのような変数には、
以下のものがあります(将来この名前は変えられるようになる予定です)。かっこの中は、
yacc での表記です。

<dl>
<dt>result ($$)
<dd>
左辺の値。初期値は val[0] です。

<dt>val ($1,$2,$3…)
<dd>
右辺の値の配列。Rubyの配列なので当然インデックスはゼロから始まります。
この配列はユーザーの好きなように使えます。

<dt>_values (...,$-2,$-1,$0)
<dd>
値スタック。サイズを変更してはいけません。

</dl>

<p>
さらに、バージョン 0.10.3 からは埋めこみアクションをサポートしました。
埋めこみアクションはトークン列の途中の好きなところに記述することができます。
以下は埋めこみアクションの例です。
<pre>

target: A B { puts 'test test' } C D { normal action };

</pre>
このように記述すると A B を検出した直後(本当は違うが。) puts が実行されます。
また、埋めこみアクションはそれ自体が値を持ちます。つまり、以下の例において
<pre>

target: A { result = 1 } B { p val[1] };

</pre>
p val[1] は埋めこみアクションの値 1 を表示します。B の値ではありません。

<p>
さらに、意味的には埋めこみアクションは
空の規則を持つ非終端記号を追加することと全く同じ働きをします。
つまり、上記の例は以下と全く同じ意味です。
<pre>

target: A nonterm B { p val[1] };
nonterm: /* void */ { result = 1 };

</pre>


<h4><a name="prec">演算子優先順位</a></h4>

<p>
あるトークン上でシフト・還元衝突がおこったとき、そのトークンに演算子優先順位が設定して
あると、衝突を解消できる場合があります。そのようなものとして特に有名なのは数式の
演算子と (だから演算子優先順位っていうのか (^^;; ) if...else構文です。

<p>
優先順位で解決できる文法は、うまく文法をくみかえてやれば、必ず優先順位なしでも同じ
効果を得られます。しかしたいていの場合、優先順位を設定するほうが、文法が簡単になります。

<p>
シフト・還元衝突がおこったとき、Raccはまずその規則に順位が設定されているか調べます。
規則の順位は、その規則で一番うしろにある終端トークンの優先順位です。たとえば、
<pre>
      target: TERM_A nonterm_a TERM_B nonterm_b ;
</pre>
のような規則の順位はTERM_Bの優先順位になります。もしTERM_Bに優先順位が設定されて
いなかったら、優先順位で衝突を解決することはできないと判断し、
「Shift/Reduce conflict」を報告します。

<p>
演算子優先順位は、つぎのように書きます。<br>
prechigh に近いほうが、順位の「高い」トークンです。上下をまるごとさかさまにして、
preclow...prechigh の順番に書くこともできます。
<pre>

    prechigh
      nonassoc PLUSPLUS
      left     MULTI DEVIDE
      left     PLUS MINUS
      right    '='
    preclow

</pre>
left right nonassoc はそれぞれ「右結合」「左結合」「結合しない」をあらわします。

<p>
また、通常は還元する規則の、最後のトークンが順位を決めますが、ある規則に限って
順位をあげたいときがあります。yaccで言えば%precです。たとえば、符号反転のマイナスは
引き算のマイナスより順位を高くしないといけません。
<pre>

    prechigh
      nonassoc UMINUS
      left '*' '/'
      left '+' '-'
    preclow
(略)
    exp: exp '*' exp
       | exp '-' exp
       | '-' exp   =   UMINUS    # 順位を上げる

</pre>
このように記述すると、'-' exp の規則の順位がUMINUSの順位になります。こうすることで、
符号反転の'-'は'*'よりも順位が高くなるので、正常に処理されます。


<h4><a name="start">スタート規則</a></h4>

<p>
パーサをつくるためには、どの規則が「最初の」規則か、ということをRaccにおしえて
やらなければいけません。それを明示的に書くのがスタート規則です。スタート規則は
次のように書きます。
<pre>

      start real_target

</pre>
このように書くと、real_targetの規則をスタート規則として使います。省略すると、
一番上にある規則がスタート規則になります。普通は、最初の規則を一番上にかくほうが
書きやすく、わかりやすくなりますから、start はあまりつかう必要はないでしょう。


<h4><a name="token">トークンシンボル値の変更</a></h4>

<p>
トークンシンボルを表す値は、デフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの(RULEとかXENDとか)<br>
    →その名前の文字列をinternして得られる整数
<li>引用符でかこまれているもの(':'とか'.'とか)<br>
    →その文字列そのまま
</ul>

<p>
となっていますが、たとえば他の形式のスキャナがすでに存在する場合などは、
これにあわせなければならず、このままでは不便です。このような場合には、
token節を加えることで、トークンシンボルを表す値を変えることができます。
以下がその例です。
<pre>

    token
      PLUS 'PlusClass'      # --> PlusClass
      MIN  'MinusClass'     # --> MinusClass
    end

</pre>
デフォルトでは、トークンシンボルPLUSに対してはトークンシンボル値は:PLUSですが、
上のような記述がある場合は、PlusClassになります。
変換後の値は false、nil 以外ならなんでも使えます。

<p>
変換後の値として文字列を使うときは、次のように引用符を重ねる必要があります。
<pre>

    token
      PLUS '"plus"'       # --> "plus"
    end

</pre>

<p>
また、「'」を使っても生成された Ruby のコード上では「"」になるので注意してください。
バックスラッシュによるクオートは有効ですが、バックスラッシュは消えずにそのまま
残ります。<em>これは仕様です。バグではありません。</em>
<pre>

      PLUS '"plus\n"'          # --> "plus\n"
      MIN  "\"minus#{val}\""   # --> \"minus#{val}\"

</pre>


<h3><a name="usercode">ユーザーコード部</a></h3>

<p>
ユーザーコード部には、パーサクラスの内部または外部で使用するRubyのコードを書きます。
<a href="command.html">raccコマンド</a>では、header inner footer の
3つをコードの名前として使い、それぞれを生成するファイルの特定の場所に転写しています。

<p>
ユーザーコード部の書式は以下の通りです。
<pre>

---- ユーザーコードの識別子
  rubyの文
  rubyの文
  rubyの文

---- 次のユーザーコードの識別子
  rubyの文
     :

</pre>
行の先頭から4つ以上連続した「-」があるとユーザーコードとみなされます。
識別子は一つの単語で、そのあとには「=」以外なにを書いてもかまいません。

<p>
また、次のような文で外部ファイルをユーザーコードとしてインクルードすることもできます。
<pre>

---- 識別子 = ファイル名 ファイル名 ファイル名 .....

</pre>
このように書くと、すべてのファイルの内容をその順番につなげたものが
そのユーザーコードになります。次はその例です。
<pre>

---- footer = init.rb err.rb run.rb

print "this line is added, too\n"

</pre>
ここでは init.rb と run.rb を footer コードとして指定しています。
----のある行の下に書いたもの(printのある行など)もつづけて加えられます。
さきほど ---- のある行の識別子のあとはなにを書いてもいいと言いましたが、
ファイルを記述する場合に限ってはなにも書くことができません。
コメントなどもだめです。正確にファイル名だけをならべて書いてください。
この制限はもちろん「対応するのがめんどくさかったから」です ^^;;;


. footer
. file parser.html ------------------------------------------------
. header Parser

<h1>parser.rb</h1>

<hr>

<h2><a name="parser">Parserクラス</a></h2>

<p>
Raccの生成するパーサはすべてParserクラスを継承しています。
Parserクラスにはパース中に使用するメソッドがいくつかあり、
そのようなメソッドをオーバーロードすると、パーサの初期化などができます。

<p>
逆に言えば、これらのメソッドを変に再定義すると挙動がおかしく
なりますので注意してください。


<h3>ファイル</h3>
  racc/parser.rb

<h3>スーパークラス</h3>
  Object


<h3>メソッド</h3>

<dl>
<dt>next_token (abstract)
<dd>
パーサが次のトークンを読みこむ時に使います。[トークンシンボル,その値]
の形式の配列を返してください。トークンシンボルの値は、デフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの<br>
    →その名前の文字列をinternして得られる整数(たとえば:ATOM)
<li>引用符でかこまれているもの<br>
    →その文字列そのまま(たとえば、'=')
</ul>
です。これを変更する方法については、
<a href="grammer.html#token">文法リファレンス</a>を参照してください。

<p>
また、もう送るシンボルがなくなったときには、[false,false] を返してください。
これを忘れるとわけのわからないパースエラーになります。(一回送れば十分です)

<p>
また、このメソッドは抽象メソッドなので、<em>必ず</em>下位クラスで再定義する
必要があります。定義しないままパースを始めると例外が発生します。


<dt>on_error( err_tok, err_val, _values )
<dd>
パースエラーを検出したとき、よびだされます(yyerror)。
メッセージを出すなり、例外を発生するなりしてください。
このメソッドからもどったあとは、パーサはエラー回復モードに移行します。<br>
引数は、err_tok がパースエラーをおこしたシンボルトークン(内部表現)、
err_val がその値、残りはアクションで渡されるものと同じです。

<p>
デフォルトでは、例外ParseErrorを発生します。

</dl>

<h3>定数</h3>

プリフィックス "LR_" がついた定数(共有変数)はパーサの予約定数です。
そのような定数は使わないでください。パース不可能になります。


. footer
. file debug.html
. header debug info

<h1>デバッグ情報</h1>

<hr>
<p>
ここでは、Racc を使っていくうえで遭遇しそうなバグについて書きます。
ただ、徐々に減ってはいますが、現時点ではまだまだracc自身のバグの可能性も高いです。
もし「これはバグに違いない！」というエラーに遭遇したらメールをください。
そのときは、規則ファイルなどもつけてくださるようお願いします。

<p>
また、racc コマンドに -v オプションをつけてコンパイルすると、内部情報が
"ファイル名.output" に出力されます。このファイルの情報はデバッグには
必須ですから、デバッグ中は常に-vgをつけてコンパイルすることをおすすめします。


<h2>インストールできないんだけど。</h2>
<p>
どうしたらいいんでしょうねえ。

<h2>規則ファイルがパースエラーになるよう。</h2>
<p>
エラーメッセージに出てる行に文法の間違いがあります。
どこが間違ってるかは じっと見て考えましょう。

<h2>衝突</h2>
<p>
一番ありがちな問題は、衝突でしょうか。
衝突があると、racc がコンパイル後に「衝突がある」とメッセージを
出すのですぐわかります。.outputファイルにはさらに詳しい情報が出力されます。
それをどうやって解決するか、とかそういうことに関しては、それなりの本を読んでください。
とてもここに書けるような単純な話ではありません。例えば O'Reilly の「lex & yacc」。

<h2>next_token に関して</h2>
<p>
いまだ自分でも忘れることが多いのが、「スキャンが終了したら[false, false]を送る」
ということです。0.10.2 からは一回送ったらもうそれ以上は next_token を呼びません。

<h2>デバッグ出力</h2>
<p>
raccに-gオプションをつけてコンパイルすると、デバッグ用のコードが付加されます。
ここで、パーサクラスのインスタンス変数 @yydebug を true にしておいてから
do_parse を呼ぶと、デバッグ用メッセージを出力します。パーサがシフト/還元していく
様子が直接見えますので、完全に現在の状態を把握できます。
どこで止まっているのかがわかればあとは直すだけ。

<hr>
<h2>yaccとの文法の違い</h2>


<h3>定義部</h3>
<p>
yaccでは%がいっぱいでてきますが、raccでは%は出てきません。それから、
Cは変数に型があるためにそれを指定する文法がたくさんありますが、Rubyは
型無しですからそっち関係のものはなくなっています。
<p>
yaccでは終端記号(トークン)を事前に指定しますが、raccでは左辺にこないものを自動的に
終端記号とみなします。ということはつまり、非終端記号nontermをnotermと書きまちがったが
ために、それが終端記号とみなされて、妙なことになる可能性があるということです。
これを防止するためには、.outputファイルを出力させて、変なものが終端記号になって
いないか(もちろんその逆も)チェックするとよいでしょう。
<p>
バージョン 0.10 からは全体の構造が class ... rule ... end のようになりました。


<h3>規則部</h3>
<p>
規則部分は yacc とほぼ同じですが、規則の最後のセミコロンは必須です。
<p>
%prec は = をつかいます。
<p>
yacc ではコメントは /* ... */ だけですが racc では #...(行末) もあります。


<h3>ユーザーコード部</h3>
<p>
yacc ではユーザーコードを分類する必要はありませんが、racc ではパーサがクラスなので、
配置する場所によってユーザーコードを分類しています。ユーザーコードの指定方法も
0.9 で ---- を使うように大きく変わったので気をつけてください。

. footer
. file scan.html
. header scan

<h1>スキャナ作成キットの使いかた</h1>

<hr>

<p>
パーサを使うときは、たいてい文字列をトークンに切りわけてくれる
スキャナが必要になります。しかし実は Ruby は文字列の最初からトークンに
切りわけていくという作業があまり得意ではありません。正確に言うと、
簡単にできるのですが、非常に大きいオーバーヘッドがかかります。<br>
racc に添付されている scanner.rb と strscan はこのオーバーヘッドを
回避しつつ、手軽にスキャナをつくるためのライブラリです。<br>
まあ、ちょっとしか手軽にならないんですけど…


<h2>使い方</h2>

<p>
以下に、scanner.rb を利用する簡単な例を示します。
<pre>

require 'racc/scanner'

class MyScanner < Racc::Scanner

  def scan
    while true do
      return [false, false] if @scan.empty?
      @scan.skip /\A\s+/
      if tmp = @scan.scan( /\A\w+/ ) then
        return [:WORD, tmp]
      end
    end
  end

end

</pre>
このクラスは、文字列から単語を切りだすスキャナです。
小さいクラスですが、必要な要素はつまっています。
まず、利用するときには require 'racc/scanner' すること。
自分のスキャナクラスは Racc::Scanner クラスから継承すること。
@scan がなにやらカギらしいこと。などです。

<p>
@scan に入っているのは StringScanner のインスタンスで、拡張モジュールです。
実はこのクラスがこのライブラリの核で、スキャンはこのライブラリを中心にして
行われます。<br>
Racc::Scanner は文字列を引数にして生成します。Racc::Scanner はそれを使って
StringScanner を準備し、@scan にセットしてくれます。
StringScanner は文字列と「どこまでスキャンしたか」を示すポインタがセットに
なったようなオブジェクトで、正規表現とのマッチをおこなってそのポインタを
進めていくことでスキャンを行います。

<p>
StringScanner の重要なメソッドは 3 つです。<br>
scan は最も重要なメソッドで、与えられた正規表現がマッチする部分を切り出して
返します。skip はマッチした部分の先にポインタを進めるだけで、真偽値を返します。
empty? はポインタが最後までいったかどうかを真偽値で返すメソッドです。

<p>
ちなみに、マッチに使う正規表現は必ず文字列の先頭からマッチしなければいけません
(ようは、 /\A…/ じゃないとだめってことです)。もし先頭より後でマッチした場合は、
マッチしたところまで全部がマッチしたものとみなされてしまいます。例えば次のような場合は
<pre>

s = StringScanner.new( "word   word" )
ret = s.scan( /\s+/ )

</pre>
何事もなかったかのように ret には "word  " が返り、ポインタはその先の w に
セットされます。先頭からマッチしなかった場合、それを知る手段はありません。

<p>
あとは、以下のリファレンスなどを見て考えてください(いいかげんだな)。

<hr>

<h2>StringScannerクラスリファレンス</h2>


<h3>クラスメソッド</h3>

<dl>
<dt>new( str, dup_p = true )
<dd>
新しいStrScannerオブジェクトを生成します。strはスキャンする文字列、dup_pは
文字列を複製して使うかどうかを真偽値で指定します。

<p>
dupしないと生成が高速になりますが、その場合もとの文字列からとりだしたポインタを
そのまま使うので、もしスキャン中にその文字列がガーベージコレクトされると落ちます。
また、他のスレッドがその文字列を触れるときも危険です。StrScannerでは最初に取得した
ポインタと長さを最後まで使うので、もし文字列が短かく変更されたり、realloc がおこったり
すると落ちます。

</dl>


<h3>メソッド</h3>
<dl>
<dt>scan( regex )
<dd>
正規表現regexとマッチを行って、マッチしたらスキャンポインタを進めたうえで
その部分の文字列を返し、マッチしなかったらnilを返します。

<dt>skip( regex )
<dd>
正規表現regexとマッチを行って、マッチしたらスキャンポインタを進めたうえで
マッチした文字列の長さを返し、マッチしなかったらnilを返します。

<dt>match?( regex )
<dd>
正規表現regexとマッチを行って、マッチしたらスキャンポインタは進めずに
マッチした文字列の長さを返し、マッチしなかったらnilを返します。

<dt>getch
<dd>
スキャンポインタから一文字を文字列として返し、ポインタを進めます。

<dt>empty?
<dd>
ポインタの後ろにもう文字列がないとき真。

<dt>rest?
<dd>
ポインタの後ろにまだ文字列があるとき真。

<dt>rest
<dd>
ポインタ以降の文字列を返します。

<dt>restsize
<dd>
ポインタ以降の文字列の長さを返します。

<dt>matched?
<dd>
前回のマッチが成功したかどうかを真偽値で返します。

<dt>matched
<dd>
前回マッチした部分の文字列を返します。

<dt>matchedsize
<dd>
前回マッチした部分の文字列の長さを返します。

<dt>self[n]
<dd>
前回マッチした正規表現の n 番目のかっこに対応する部分文字列を返します。
0 はマッチした部分全体です。

<dt>string
<dd>
スキャン対象にしている文字列を返します。

<dt>reset
<dd>
ポインタを最初に戻し、マッチ記録を捨てます。

<dt>clear
<dd>
ポインタを最後まで進め、マッチ記録を捨てます。

<dt>unscan
<dd>
ポインタをスキャン一回分もとに戻します。一回分以上は戻せません。

</dl>

. footer
. file changes.html ----------------------------------------------------------
. header Changes

<h1>変更履歴</h1>

<hr>
<h2>0.10.9(2000/01/19)</h2>
<p>
<ul>
<li>セットアップ方法など細かな変更
</ul>

<h2>0.10.8(2000/01/03)</h2>
<p>
<ul>
<li>忘れてしまったけどたしかインストーラ関係の修正
<li>(1/17 re-packed) ドキュメントの追加と修正
</ul>

<h2>0.10.7(2000/01/03)</h2>
<p>
Thanks 新井さん
<ul>
<li>setup.rb compile.rb amstd/inst などのバグ修正
</ul>

<h2>0.10.6(1999/12/24)</h2>
<p>
<ul>
<li>racc -e ruby でデフォルトパスを使用
<li>空のアクション呼びだしを省略
</ul>

<h2>0.10.5(1999/12/21)</h2>
<p>
thanks Toshさん
<ul>
<li>埋めこみアクションの実装がすさまじくバグってた
<li>setup.rb が inst.rb の変化に追従してなかった
<li>calc.y calc2.y を 0.10 用に修正
</ul>

<h2>0.10.4(1999/12/19)</h2>
<p>
<ul>
<li>エラー回復モードを実装
<li>racc -E で単体で動作するパーザを生成
<li>Racc は class から module になった
</ul>

<h2>0.10.3(1999/12/01)</h2>
<p>
<ul>
<li>埋めこみアクションをサポート
<li>.output の出力内容にバグがあったのを修正
</ul>

<h2>0.10.2(1999/11/27)</h2>
<p>
<ul>
<li>ドキュメントの訂正と更新
<li>libracc.rb を分割
</ul>

<h2>0.10.1(1999/11/19)</h2>
<p>
<ul>
<li>C でランタイムを書きなおした
<li>next_token が false を返したらもう読みこまない
<li>アクションがトークンによらず決まるときは next_token を呼ばない
<li>$end 廃止
<li>LALRactionTable
</ul>

<h2>0.10.0(1999/11/06)</h2>
<p>
<ul>
<li>next_* を next_token に一本化、peep_token 廃止
<li>@__debug__ -&lt; @yydebug など変数名を大幅変更
<li>文法ファイルの構造が class...rule...end に変わった
<li>コアのコードを一新、高速化
<li>strscan を併合
<li>ライブラリを racc/ ディレクトリに移動
</ul>

<hr>
<h2>0.9.5(1999/10/03)</h2>
<p>
thanks > Toshさん
<ul>
<li>0.9.4 の変更がすごくバグってた
<li>$end が通らなかったのを修正
<li>__show_stack__ の引数が違ってた
</ul>

<h2>0.9.4(1999/09/??)</h2>
<p>
<ul>
<li>Parser::Reporter をなくしてメソッドに戻した
<li>d.format.rb を再編成
</ul>

<h2>0.9.3(1999/09/03)</h2>
<p>
<ul>
<li>racc.rb -> racc
</ul>

<h2>0.9.2(1999/06/26)</h2>
<p>
<ul>
<li>strscan使用
</ul>

<h2>0.9.1(1999/06/08)</h2>
<p>
<ul>
<li>アクション中の正規表現に対応 ( /= にも注意だ)
<li>アクション中の # コメントに対応
</ul>

<h2>0.9.0(1999/06/03)</h2>
<p>
<ul>
<li>アクションを { } 形式にした
<li>ユーザーコードを '----' を使う形式にした
</ul>


<hr>

<h2>0.8.11</h2>
<p>
<ul>
<li>-g 出力をわかりやすくした
</ul>

<h2>0.8.10</h2>
<p>
<ul>
<li>アクションからreturnできるようにした
</ul>

<h2>0.8.9(1999/03/21)</h2>
<p>
<ul>
<li>-g + @__debug__をつかったデバッグメッセージ操作
<li>エラー発生時のバグを修正
<li>TOKEN_TO_S_TABLEを付加するようにした
</ul>

<h2>0.8.8(1999/03/20)</h2>
<p>
<ul>
<li>100倍程度の高速化
<li>defaultトークンを加えた
<li>デバッグ用ソースを出力するオプション-gをくわえた
<li>user_initializeを廃止し、普通にinitializeを使えるようにした
<li>parse_initialize/finalize,parseメソッドを廃止
<li>next_token,next_value,peep_tokenのデフォルトを廃止
<li>%precと同等の機能を加えた
</ul>

<h2>0.8.7(1999/03/01)</h2>
<p>
<ul>
<li>内部構造が大幅に変化
<li>マニュアルがHTMLになった
</ul>

<h2>0.8.0(1999/01/16)</h2>
<p>
なぜいきなり 0.8 ？？？
<ul>
<li>文法がブロック型に変化
</ul>

<h2>0.5.0(1999/01/07)</h2>
<p>
<ul>
<li>演算子優先順位が実装されたようだ
<li>スタート規則が実装されたようだ
<li>トークン値の置換が実装されたようだ(後に致命的なバグ発見)
</ul>

<h2>0.1.0(1999/01/01)</h2>
<p>
とにかく動くようになった

. footer