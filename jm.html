. file index.html -------------------------------------------------------
<% header 'Racc User Manual' %>

<h1>Racc user manual</h1>

updated for version 0.14

<p>
Racc は文法規則から Ruby で書かれたパーサを生成するパーサジェネレータです。
パーサ生成アルゴリズムとして、yacc などと同じ LALR(1) を使用しています。

<ul>
<li><a href="usage.html">Racc の使い方</a>
<li><a href="command.html">racc コマンドリファレンス</a>
<li><a href="grammer.html">規則ファイル文法リファレンス</a>
<li><a href="parser.html">Parser クラスリファレンス</a>
<li><a href="debug.html">デバッグ情報</a>
<li><a href="changes.html">変更履歴</a>
</ul>

<% footer 1999 %>
. file usage.html --------------------------------------------------------
<% header 'Usage' %>

<h1>Racc の使い方</h1>

<h2>ひとの作ったパーサを使う</h2>

<p>
もうすでに文法ファイルがある場合です。この場合は単に racc コマンドが使えればよく、
文法ファイルの書きかたを覚えたりする必要はありません。

<p>
文法ファイルの名前が parse.y と仮定すると、コマンドラインから以下のように
打ちこむことで、パーサを含んだファイルが得られます。
<pre>

$ racc parse.y

</pre>
生成されるファイルはデフォルトでは "ファイル名.tab.rb" になります。
これは -o オプションで変更できます。


<h2>自分でパーサを作る</h2>

<p>
自分で racc の文法ファイルを記述する場合です。
racc は yacc を知っていることを前提にしていますので、もし知らないのなら
先に yacc を勉強しましょう。いきなり racc を使うのは不可能です。(これは断言できます)

<h3>概観</h3>
<p>
yacc は yyparse (関数)を生成しますが、racc は yyparse に相当する do_parse
メソッドを持ったパーサクラスを生成します。
生成されるクラスは全て Racc::Parser の下位クラスで、規則ファイル中で指定します。
規則ファイルの文法の詳細は、<a href="grammer.html">文法リファレンス</a>を
参照してください。

<h3>規則ファイル</h3>
<p>
以下には規則ファイルの文法の概略だけ書いておきます。<br>
まずは、全体の概形です。
<pre>

class MyParser

rule
  target : exp
         ;
  exp    : tok { print val[0] }
         | exp tok    # これはコメント
               { print val[1] }
         ;
  tok    : A
         | '+'
         | '-'       /* これもコメント */
         ;
end

</pre>
Rubyスクリプトのように class でクラス名を指定し、rule ... end の間に文法を記述します。
トークンは Ruby のローカル変数/定数として有効なものが使えます。
yacc だと終端記号を %token で指定する必要がありますが、racc ではそのような
指定は必要ありません。左辺に来ないトークンはすべて終端記号とみなされます。

<p>
アクションは、yacc と同じように規則のあとに { と } で囲んで指定します。
当然ながら、アクションは Ruby の文で記述します。<br>
yacc での $$ は Racc ではローカル変数 result で、$1,$2... は配列 val です。
result は val[0]($1) の値に初期化され、アクションを抜けたときの result の値が
左辺値になります。Racc ではアクション中の return はアクションから抜けるだけで、
パーズ自体は終わりません。
アクション中からパーズを終了するには、メソッド yyaccept を使ってください。

<p>
演算子の優先順位、スタートルールなどの yacc の一般的な機能も用意されています。
ただしこちらも少し文法が違います。

<p>
yacc では生成されたコードに直接転写されるコードがありました。Racc でも同じように、
ユーザ指定のコードが書けます。racc ではクラスを生成するので、クラス定義の前/中/後の
三個所があります。Racc ではそれを上から順番に header inner footer と呼んでいます。
0.10.1 までは prepare inner driver でしたがかっこわるいので変更しました。
ただし、互換性のため前のままでも使えるようになっています。

<h3>ユーザが用意すべきコード</h3>
<p>
inner では、Racc の yylex に相当するメソッド next_token を定義する必要があります。
このメソッドは、トークンシンボルとその値の二要素を持つ配列を返すようにします。
この配列を Racc が破壊することはありません。また、どこか他のところで使うことも
ありません。<br>
スキャンが終了して、もう送るものがない場合は [false,なにか] を返してください。
[false,なにか] を一回受けとったらそれ以上 next_token は呼びだされません。

<p>
パーザは別に文字列処理にだけ使われるものではありませんが、実際問題として、
パーザを作る場面ではたいてい文字列のスキャナとセットで使うことが多いでしょう。
Ruby ならスキャナくらい楽勝で作れますが、高速なスキャナとなると実は難しかったり
します。そこで、高速なスキャナを作成するためのライブラリが同梱されています。
詳しくは<a href="#scanner">「スキャナを作る」の項</a>を見てください。

<p>
Racc には、error トークンを使ったエラー回復機能もあります。<br>
yacc の yyerror() は Racc では <a href="parser.html">Parser#on_error</a>で、
エラーがおきたトークンとその値、値スタックの 3 引数をとります。
on_error はデフォルトでは例外 ParseError を発生します。<br>
ユーザがアクション中でパースエラーを発見した場合は、
メソッド yyerror を呼べばパーサがエラー回復モードに入ります。
このときは on_error は呼ばれないので、なにか報告をしたい時はユーザが明示的に
on_error を呼んだりする必要があります。

<h3>パーザを生成する</h3>
<p>
これだけあればだいたい書けると思います。あとは、最初に示した方法でコンパイルし、
Rubyスクリプトを得ます。<br>
うまくいけばいいのですが、大きいものだと最初からはうまくいかないでしょう。
racc に -g オプションをつけてコンパイルし、@yydebug を true にすると
デバッグ用の出力が得られます。また、-v オプションをつけると、
状態遷移表を読みやすい形で出力したファイル(.output)が得られます。
どちらもデバッグの参考になると思います。


<h2>作ったパーザを配布する</h2>
<p>
Racc の生成したパーザは動作時にランタイムルーチンが必要になります。
具体的には parser.rb と cparse.so それと amstd/ のスクリプトが少しです。
cparse.so は高速にパーズするための拡張モジュールで、amstd/ はユーティリティ、
parser.rb はそれらすべてのフロントエンドです。<br>
これらのファイルを自分でセットアップするのはなかなか面倒です。
Racc をユーザみんなにインストールしてもらうのも一つの手ですが、
これではユーザにとって不親切です。
そこで、Racc では回避策をふたつ用意しました。

<h3>ランタイム配布の自動化</h3>
<p>
ひとつめは、ランタイムとそのインストーラをまるごと自分のソフトのパッケージに
含めてしまうことです。方法は簡単で、Racc パッケージのトップディレクトリに
入って次のように起動します。
<pre>

ruby rtpack.rb TARGET/

</pre>
これで、ディレクトリ TARGET/ 以下に必要なファイルがインストールされます。
このとき、一度 TARGET/ 以下をクリアするので気をつけてください。

<p>
また、インストール時には、TARGET/ に移動して ruby setup.rb を実行すれば
ランタイムをインストールできます。

<p>
この方法だと、速度を保ったまま、パーザを配布できるのが利点です。

<h3>-E オブションを使う</h3>
<p>
racc に -E オプションをつけてコンパイルすると、必要なものを全部結合した
ファイルが得られます。これだとファイルはひとつだけなので扱いが楽です
(この形式のパーザが複数あったとしてもクラスやメソッドが衝突することは
ありません)。

<p>
この方法だと、特別なことはなにもする必要がないので、非常に扱いが楽です。
ただし、cparse.so が使えませんので、必然的に動作は Ruby スクリプトのみになり
速度は低下します。<br>
ただし、これも例外があって、配布先に既に Racc ランタイムがあるときは
自動的にそちらが使われます。


<h2><a name="scanner">おまけ：スキャナを作る</a></h2>
<p>
パーサを使うときは、たいてい文字列をトークンに切りわけてくれる
スキャナが必要になります。しかし実は Ruby は文字列の最初からトークンに
切りわけていくという作業があまり得意ではありません。正確に言うと、
簡単にできるのですが、非常に大きいオーバーヘッドがかかります。<br>
racc に添付されている scanner.rb と strscan はこのオーバーヘッドを
回避しつつ、手軽にスキャナをつくるためのライブラリです。<br>
ただし本当にちょっとしか手軽になりません。

<h3>使い方</h3>
<p>
以下に、scanner.rb を利用する簡単な例を示します。
<pre>

require 'racc/scanner'

class MyScanner < Racc::Scanner

  def scan
    while true do
      return [false, false] if @scan.empty?
      @scan.skip /\A\s+/
      if tmp = @scan.scan( /\A\w+/ ) then
        return [:WORD, tmp]
      end
    end
  end

end

</pre>
このクラスは、文字列から単語を切りだすスキャナです。
小さいクラスですが、必要な要素はつまっています。
まず、利用するときには require 'racc/scanner' すること。
自分のスキャナクラスは Racc::Scanner クラスから継承すること。
@scan がなにやらカギらしいこと。などです。

<p>
@scan に入っているのは StringScanner のインスタンスで、拡張モジュールです。
このクラスがこのライブラリの核で、スキャンはこのライブラリを中心にして
行われます。<br>
Racc::Scanner は文字列を引数にして生成します。Racc::Scanner はそれを使って
StringScanner を準備し、@scan にセットしてくれます。
StringScanner は文字列と「どこまでスキャンしたか」を示すポインタがセットに
なったようなオブジェクトで、正規表現とのマッチをおこなってそのポインタを
進めていくことでスキャンを行います。

<p>
StringScanner の重要なメソッドは 3 つです。<br>
scan は最も重要なメソッドで、与えられた正規表現がマッチする部分を切り出して
返します。skip はマッチした部分の先にポインタを進めるだけで、真偽値を返します。
empty? はポインタが最後までいったかどうかを真偽値で返すメソッドです。<br>
他にもいろいろメソッドがあるのですが、ここでは紹介しません。
StringScanner の詳細は、strscan 本体のパッケージについているドキュメントを
参照してください。

<% footer 1999 %>
. file command.html -----------------------------------------------------------
<% header 'Racc Command' %>

<h1>Raccコマンドリファレンス</h1>

<hr>

<p align=justify>
  racc.rb [-vgE] [--version] [--help] [-o<var>outfile</var>] [-e<var>path</var>]
    [-n<var>classname</var>] [-h<var>header</var>] [-i<var>inner</var>]
    [-f<var>footer</var>] <var>filename</var>
</p>

<dl>
<dt><var>filename</var>
<dd>
Raccの文法ファイルを指定します。拡張子は好きなものにしてください。

<dt>-o<var>outfile</var>
<dd>
作成するクラスをかきこむファイル名を指定します。デフォルトは<filename>.tab.rbです。

<dt>-e<var>path</var>
<dd>
実行可能ファイルを生成します。<var>path</var>はRuby本体のパスです。
<var>path</var>を 'ruby' にすると Racc が動作している Ruby のパスを使用します。

<dt>-v
<dd>
verbose mode。"filename".outputファイルに詳細な解析情報を出力します。

<dt>-g
<dd>
出力するコードにデバッグ用コードを加えます。-g をつけて生成したパーサで
@yydebug を true にセットすると、デバッグ用のコードが出力されます。<br>
-g をつけるだけでは何もおこりませんので注意してください。

<dt>-E
<dd>
ランタイムルーチンをすべて含んだコードを生成します。
つまり、このオプションをつけて生成したコードは Ruby さえあれば動きます。

<dt>-n<var>classname</var>
<dd>
作成するクラスの名前を指定します。文法中の指定を上書きします。

<dt>-h<var>header</var>
<dd>
文法ファイル中の「header」コードのかわりに、指定したファイルの内容を
使ったソースコードを出力します。

<dt>-i<var>inner</var>
<dd>
文法ファイル中の「inner」コードのかわりに、指定したファイルの内容を使った
ソースコードを出力します。

<dt>-f<var>footer</var>
<dd>
文法ファイル中の「driver」コードのかわりに、指定したファイルの内容を使います。

<dt>-P
<dd>
実行段階ごとの所要時間を出力します。

<dt>-V
<dd>
衝突解決の進行状況を逐一報告します。

<dt>--version
<dd>
Raccのバージョンを出力して終了します。

<dt>--help
<dd>
オプションの簡単な説明を出力して終了します。

</dl>

<% footer 1999 %>
. file grammer.html -----------------------------------------------------
<% header 'Grammer Reference' %>

<h1>規則ファイル文法リファレンス</h1>

<hr>

<p>
バージョン 0.10.3 では埋めこみアクションをサポートしました。<br>
バージョン 0.10.2 では prepare が header に driver が footer になりました。
前のままでも使えますが将来は消えるかもしれません。<br>
バージョン 0.10 では class に対応する end がなくなり、
class...rule...end の形になりました。<br>
0.9 ではダサダサのピリオド方式をやめて { と } で囲むようにしました。


<h2><a name="whole">全体の構造</a></h2>

<p>
トップレベルは、規則部とユーザーコード部に分けられます。
ユーザーコード部はクラス定義の後に来なければいけません。


<h3><a name="comment">コメント</a></h3>

<p>
文法ファイルには、一部例外を除いて、ほとんどどこにでもコメントを
書くことができます。コメントは、Rubyの #.....(行末) スタイルと、
Cの /*......*/ スタイルを使うことができます。


<h3><a name="class">規則部</a></h3>

<p>
規則部は以下のような形をしています。
<pre>

    class クラス名
      [演算子順位]
      [スタート規則]
      [トークンシンボル値定義]
    rule
      文法記述
    end

</pre>
"クラス名"はここで定義するパーサクラスの名前です。
これはそのままRubyのクラス名になります。


<h4><a name="grammer">文法の記述</a></h4>

<p>
racc で生成するパーサが理解できる文法を記述します。
文法は、予約語 rule と end の間に、以下のような書式で書きます。
<pre>

      トークン: トークンの並び アクション ;

      トークン: トークンの並び アクション
              | トークンの並び アクション
              | トークンの並び アクション
              ;
                  (必要なだけ同じようにつづける)

</pre>
書式は yacc とほぼ同じです。ただし、セミコロンは必須です。アクションがあっても
省略してはいけません。

<p>
アクションは { } で囲みます。ただしまだ対応が不十分なので、
中では % 文字列やヒアドキュメントは使えません。コメントは # タイプのみ。
正規表現は // タイプのみです
(本当は'}'がはいってなければどれも大丈夫ですが、やらないほうが無難です)。<br>
また、アクションは省略できます。省略すると、デフォルトの val[0] が返り値になります。

<p>
右辺の返り値($$)は、アクションから出たときのローカル変数 result の値か、
もしくは明示的に return で返した値になります。また、result はアクション実行の前に
val[0]($1)に初期化されます。<br>
以下に文法記述の全体の例をしめします。
<pre>

rule

  goal: def ruls source
        {
          result = val
        }
      ;

  def : /* none */
        {
          result = []
        }
      | def startdesig
        {
          result[0] = val[1]
        }
      | def
          precrule   # これは上の行の続きです。
        {
          result[1] = val[1]
        }
      ;
(略)
end  # endで規則部終了

</pre>
アクション内では、いくつか特別な意味をもった変数が使えます。そのような変数には、
以下のものがあります(将来この名前は変えられるようになる予定です)。かっこの中は、
yacc での表記です。

<dl>
<dt>result ($$)
<dd>
左辺の値。初期値は val[0] です。

<dt>val ($1,$2,$3…)
<dd>
右辺の値の配列。Rubyの配列なので当然インデックスはゼロから始まります。
この配列はユーザーの好きなように使えます。

<dt>_values (...,$-2,$-1,$0)
<dd>
値スタック。<em>絶対に</em>サイズを変更してはいけません。

</dl>

<p>
さらに、バージョン 0.10.3 からは埋めこみアクションをサポートしました。
埋めこみアクションはトークン列の途中の好きなところに記述することができます。
以下は埋めこみアクションの例です。
<pre>

target: A B { puts 'test test' } C D { normal action };

</pre>
このように記述すると A B を検出した時点で puts が実行されます。
また、埋めこみアクションはそれ自体が値を持ちます。つまり、以下の例において
<pre>

target: A { result = 1 } B { p val[1] };

</pre>
p val[1] は埋めこみアクションの値 1 を表示します。B の値ではありません。

<p>
意味的には、埋めこみアクションは空の規則を持つ非終端記号を追加することと
全く同じ働きをします。つまり、上の例は次のコードと全く同じ意味です。
<pre>

target  : A nonterm B { p val[1] };
nonterm : /* 空の規則 */ { result = 1 };

</pre>


<h4><a name="prec">演算子優先順位</a></h4>

<p>
あるトークン上でシフト・還元衝突がおこったとき、そのトークンに
演算子優先順位が設定してあると、衝突を解消できる場合があります。
そのようなものとして特に有名なのは数式の演算子と
(だから演算子優先順位っていうのか (^^;; ) if...else 構文です。

<p>
優先順位で解決できる文法は、うまく文法をくみかえてやれば、必ず優先順位なしでも同じ
効果を得られます。しかしたいていの場合、優先順位を設定するほうが、文法が簡単になります。

<p>
シフト・還元衝突がおこったとき、Racc はまずその規則に順位が設定されているか調べます。
規則の順位は、その規則で一番うしろにある終端トークンの優先順位です。たとえば、
<pre>
      target: TERM_A nonterm_a TERM_B nonterm_b ;
</pre>
のような規則の順位はTERM_Bの優先順位になります。もしTERM_Bに優先順位が設定されて
いなかったら、優先順位で衝突を解決することはできないと判断し、
「Shift/Reduce conflict」を報告します。

<p>
演算子優先順位は、つぎのように書きます。<br>
prechigh に近いほうが、順位の「高い」トークンです。上下をまるごとさかさまにして、
preclow...prechigh の順番に書くこともできます。
<pre>

    prechigh
      nonassoc PLUSPLUS
      left     MULTI DEVIDE
      left     PLUS MINUS
      right    '='
    preclow

</pre>
left などは必ず行の最初の単語でなければいけません。<br>
left right nonassoc はそれぞれ「右結合」「左結合」「結合しない」をあらわします。

<p>
通常は、還元する規則の最後のトークンが順位を決めますが、
ある規則に限って順位をあげたいときがあります。yacc で言えば %prec です。
たとえば、符号反転のマイナスは引き算のマイナスより順位を高くしないといけません。
<pre>

    prechigh
      nonassoc UMINUS
      left '*' '/'
      left '+' '-'
    preclow
(略)
    exp: exp '*' exp
       | exp '-' exp
       | '-' exp     = UMINUS    # 順位を上げる

</pre>
このように記述すると、'-' exp の規則の順位が UMINUS の順位になります。こうすることで、
符号反転の '-' は '*' よりも順位が高くなるので、意図どおりになります。


<h4><a name="start">スタート規則</a></h4>

<p>
パーサをつくるためには、どの規則が「最初の」規則か、ということを Racc におしえて
やらなければいけません。それを明示的に書くのがスタート規則です。スタート規則は
次のように書きます。
<pre>

      start real_target

</pre>
start は行の最初にこなければいけません。<br>
このように書くと、real_target の規則をスタート規則として使います。
省略した場合は、一番上にある規則がスタート規則になります。
普通は、最初の規則を一番上にかくほうが書きやすく、わかりやすくなりますから、
start はあまりつかう必要はないでしょう。


<h4><a name="token">トークンシンボル値の変更</a></h4>

<p>
トークンシンボルを表す値は、デフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの(RULEとかXENDとか)<br>
    →その名前の文字列を intern して得られるシンボル(1.4 では Fixnum)
<li>引用符でかこまれているもの(':'とか'.'とか)<br>
    →その文字列そのまま
</ul>

<p>
となっていますが、たとえば他の形式のスキャナがすでに存在する場合などは、
これにあわせなければならず、このままでは不便です。このような場合には、
token 節を加えることで、トークンシンボルを表す値を変えることができます。
以下がその例です。
<pre>

    token
      PLUS 'PlusClass'      # --> PlusClass
      MIN  'MinusClass'     # --> MinusClass
    end

</pre>
デフォルトでは、トークンシンボルPLUSに対してはトークンシンボル値は:PLUSですが、
上のような記述がある場合は、PlusClassになります。
変換後の値は false、nil 以外ならなんでも使えます。

<p>
変換後の値として文字列を使うときは、次のように引用符を重ねる必要があります。
<pre>

    token
      PLUS '"plus"'       # --> "plus"
    end

</pre>

<p>
また、「'」を使っても生成された Ruby のコード上では「"」になるので注意してください。
バックスラッシュによるクオートは有効ですが、バックスラッシュは消えずにそのまま
残ります。<em>これは仕様です。バグではありません。</em>
<pre>

      PLUS '"plus\n"'          # --> "plus\n"
      MIN  "\"minus#{val}\""   # --> \"minus#{val}\"

</pre>


<h3><a name="usercode">ユーザーコード部</a></h3>

<p>
ユーザーコード部には、パーサクラスの内部または外部で使用するRubyのコードを書きます。
<a href="command.html">racc コマンド</a>では、header inner footer の
3つをコードの名前として使い、それぞれを生成するファイルの特定の場所に転写しています。

<p>
ユーザーコード部の書式は以下の通りです。
<pre>

---- ユーザーコードの識別子
  rubyの文
  rubyの文
  rubyの文

---- 次のユーザーコードの識別子
  rubyの文
     :

</pre>
行の先頭から4つ以上連続した「-」があるとユーザーコードとみなされます。
識別子は一つの単語で、そのあとには「=」以外なにを書いてもかまいません。

<p>
また、次のような文で外部ファイルをユーザーコードとしてインクルードすることもできます。
<pre>

---- 識別子 = ファイル名 ファイル名 ファイル名 .....

</pre>
このように書くと、すべてのファイルの内容をその順番につなげたものが
そのユーザーコードになります。次はその例です。
<pre>

---- footer = init.rb err.rb run.rb

print "this line is added, too\n"

</pre>
ここでは init.rb err.rb run.rb のみっつを footer コードとして指定しています。
さらに、---- のある行の下に書いたもの(printのある行など)がつづけて加えられます。
さきほど ---- のある行の識別子のあとはなにを書いてもいいと言いましたが、
ファイルを記述する場合はなにも書くことができません。コメントなどもだめです。
正確にファイル名だけをならべて書いてください。
この制限はもちろん「対応するのがめんどくさかったから」です ^^;;;


<% footer 1999 %>
. file parser.html ------------------------------------------------
<% header 'Parser' %>

<h1>parser.rb</h1>

<hr>

<h2><a name="parser">Parserクラス</a></h2>

<p>
Raccの生成するパーサはすべてParserクラスを継承しています。
Parserクラスにはパース中に使用するメソッドがいくつかあり、
そのようなメソッドをオーバーロードすると、パーサの初期化などができます。

<p>
逆に言えば、これらのメソッドを変に再定義すると挙動がおかしく
なりますので注意してください。


<h3>ファイル</h3>
<p>
racc/parser.rb

<h3>スーパークラス</h3>
<p>
Object


<h3>定数</h3>
<p>
プリフィックス "Racc_" がついた定数はパーサの予約定数です。
そのような定数は使わないでください。パース不可能になります。

<h3>メソッド</h3>
<dl>
<dt>next_token (abstract)
<dd>
パーサが次のトークンを読みこむ時に使います。[トークンシンボル,その値]
の形式の配列を返してください。トークンシンボルの値は、デフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの<br>
    →その名前の文字列を intern して得られるシンボル(たとえば:ATOM)
<li>引用符でかこまれているもの<br>
    →その文字列そのまま(たとえば、'=')
</ul>
です。これを変更する方法については、
<a href="grammer.html#token">文法リファレンス</a>を参照してください。

<p>
また、もう送るシンボルがなくなったときには、[false,なにか] を返してください。
これを忘れるとわけのわからないパースエラーになります。(一回送れば十分です)

<p>
また、このメソッドは抽象メソッドなので、<em>必ず</em>下位クラスで再定義する
必要があります。定義しないままパースを始めると例外が発生します。


<dt>on_error( err_tok, err_val, _values )
<dd>
パースエラーを検出したとき、よびだされます(yyerror)。
メッセージを出すなり、例外を発生するなりしてください。
このメソッドからもどったあとは、パーサはエラー回復モードに移行します。<br>
引数は、err_tok がパースエラーをおこしたシンボルトークン(内部表現の整数)、
err_val がその値、_values はその時点の値スタックです。

<p>
デフォルトでは、例外 ParseError を発生します。

<dt>yyerror
<dd>
アクション中で呼びだすとエラー回復モードに入ります。
このとき on_error は呼ばれません。

<dt>yyerrok
<dd>
アクション中で呼びだすとエラー回復モードから復帰します。

<dt>yyaccept
<dd>
このメソッドを呼びだすとすぐに値スタックの先頭の値を返して
do_parse を抜けます。

</dl>


<% footer 1999 %>
. file debug.html ----------------------------------------------------------
<% header 'Debug' %>

<h1>デバッグ情報</h1>

<hr>
<p>
ここでは、Racc を使っていくうえで遭遇しそうなバグについて書きます。
ただ、徐々に減ってはいますが、現時点ではまだまだ racc 自身のバグの可能性も高いです。
もし「これはバグに違いない！」というエラーに遭遇したらメールをください。
そのときは、規則ファイルなどもつけてくださるようお願いします。

<p>
また、racc コマンドに -v オプションをつけてコンパイルすると、内部情報が
"ファイル名.output" に出力されます。このファイルの情報はデバッグには
必須ですから、デバッグ中は常に -vg をつけてコンパイルすることをおすすめします。


<h2>インストールできないんだけど。</h2>
<p>
どうしたらいいんでしょうねえ。

<h2>規則ファイルがパースエラーになるよう。</h2>
<p>
エラーメッセージに出てる行に文法の間違いがあります。
どこが間違ってるかは じっと見て考えましょう。

<h2>衝突</h2>
<p>
一番ありがちな問題は、衝突でしょうか。
衝突があると、racc がコンパイル後に「衝突がある」とメッセージを
出すのですぐわかります。.output ファイルにはさらに詳しい情報が出力されます。
それをどうやって解決するか、とかそういうことに関しては、それなりの本を読んでください。
とてもここに書けるような単純な話ではありません。例えば O'Reilly の「lex & yacc」。

<h2>next_token に関して</h2>
<p>
いまだ自分でも忘れることが多いのが、「スキャンが終了したら[false,なにか]を送る」
ということです。0.10.2 からは一回送ったらもうそれ以上は next_token を呼びません。

<h2>デバッグ出力</h2>
<p>
racc に -g オプションをつけてコンパイルすると、デバッグ用のコードが付加されます。
ここで、パーサクラスのインスタンス変数 @yydebug を true にしておいてから
do_parse を呼ぶと、デバッグ用メッセージを出力します。パーサがシフト/還元していく
様子が直接見えますので、完全に現在の状態を把握できます。
どこで止まっているのかがわかればあとは直すだけ。

<hr>
<h2>yaccとの文法の違い</h2>


<h3>定義部</h3>
<p>
yacc では % がいっぱいでてきますが、racc では % は出てきません。
それから、C では変数に型があるためにそれを指定する文法がたくさんありますが、
Ruby は型無しですからそっち関係のものはなくなっています。
<p>
yacc では終端記号(トークン)を事前に指定しますが、
Racc では左辺にこないものを自動的に終端記号とみなします。
ということはつまり、非終端記号 nonterm を noterm と書きまちがったがために、
それが終端記号とみなされて、妙なことになる可能性があるということです。
これを防止するためには、.output ファイルを出力させて、変なものが終端記号になって
いないか(もちろんその逆も)チェックするとよいでしょう。
<p>
バージョン 0.10 からは全体の構造が class ... rule ... end のようになりました。


<h3>規則部</h3>
<p>
規則部分は yacc とほぼ同じですが、規則の最後のセミコロンは必須です。
<p>
%prec は = をつかいます。
<p>
yacc ではコメントは /* ... */ だけですが racc では #...(行末) もあります。


<h3>ユーザーコード部</h3>
<p>
yacc ではユーザーコードを分類する必要はありませんが、racc ではパーサがクラスなので、
配置する場所によってユーザーコードを分類しています。ユーザーコードの指定方法も
0.9 で ---- を使うように大きく変わったので気をつけてください。

<% footer 1999 %>
. file changes.html ----------------------------------------------------------
<% header 'Change Log' %>

<h1>変更履歴</h1>
<hr>
<h2>0.14.0(2000/03/21)</h2>
<p>
<ul>
<li>高速テーブルを実装
</ul>

<hr>
<h2>0.13.1(2000/03/21)</h2>
<p>
<ul>
<li>--version --copyright などがうまく働いてなかった (thanks ふなばさん)
</ul>

<h2>0.13.0(2000/03/20)</h2>
<p>
<ul>
<li>yyerror/yyerrok/yyaccept を実装
</ul>

<hr>
<h2>0.12.2(2000/03/19)</h2>
<p>
<ul>
<li>-E フラグがバグってた (thanks ふなばさん)
</ul>

<h2>0.12.1(2000/03/16)</h2>
<p>
<ul>
<li>デフォルトアクションの決め方をちょっと修正(元に戻しただけ)
</ul>

<h2>0.12.0(2000/03/15)</h2>
<p>
<ul>
<li>別のバグどころではなかった。先読みルーチンが LALR になっていない。
    四日がかりでようやく修正した。
<li>完全な LALR を実装したら遅くなったので SLR も併用するようにした。効果絶大。
</ul>

<hr>
<h2>0.11.3(2000/03/09)</h2>
<p>
<ul>
<li>状態遷移表生成のバグの修正がまだ甘かった。さらに別のバグもあるようだ。
</ul>

<h2>0.11.2(2000/03/09)</h2>
<p>
<ul>
<li>状態遷移表生成部に(最後(になってほしい)の)バグ。
    先読みコードが再帰した場合にトークンが少なくなってしまっていた
<li>cparse が Symbol に対応できてなかった
</ul>

<h2>0.11.1(2000/03/08)</h2>
<p>
<ul>
<li>ruby 1.5 の Symbol に対応
<li>strscan を最新に
</ul>

<h2>0.11.0(2000/02/19)</h2>
<p>
<ul>
<li>例外のとき、元のファイルの行番号が出るようにした
</ul>

<hr>
<h2>0.10.9(2000/01/19)</h2>
<p>
<ul>
<li>セットアップ方法など細かな変更
</ul>

<h2>0.10.8(2000/01/03)</h2>
<p>
<ul>
<li>忘れてしまったけどたしかインストーラ関係の修正
<li>(1/17 re-packed) ドキュメントの追加と修正
</ul>

<h2>0.10.7(2000/01/03)</h2>
<p>
Thanks 新井さん
<ul>
<li>setup.rb compile.rb amstd/inst などのバグ修正
</ul>

<h2>0.10.6(1999/12/24)</h2>
<p>
<ul>
<li>racc -e ruby でデフォルトパスを使用
<li>空のアクション呼びだしを省略
</ul>

<h2>0.10.5(1999/12/21)</h2>
<p>
thanks Toshさん
<ul>
<li>埋めこみアクションの実装がすさまじくバグってた
<li>setup.rb が inst.rb の変化に追従してなかった
<li>calc.y calc2.y を 0.10 用に修正
</ul>

<h2>0.10.4(1999/12/19)</h2>
<p>
<ul>
<li>エラー回復モードを実装
<li>racc -E で単体で動作するパーザを生成
<li>Racc は class から module になった
</ul>

<h2>0.10.3(1999/12/01)</h2>
<p>
<ul>
<li>埋めこみアクションをサポート
<li>.output の出力内容にバグがあったのを修正
</ul>

<h2>0.10.2(1999/11/27)</h2>
<p>
<ul>
<li>ドキュメントの訂正と更新
<li>libracc.rb を分割
</ul>

<h2>0.10.1(1999/11/19)</h2>
<p>
<ul>
<li>C でランタイムを書きなおした
<li>next_token が false を返したらもう読みこまない
<li>アクションがトークンによらず決まるときは next_token を呼ばない
<li>$end 廃止
<li>LALRactionTable
</ul>

<h2>0.10.0(1999/11/06)</h2>
<p>
<ul>
<li>next_* を next_token に一本化、peep_token 廃止
<li>@__debug__ -&lt; @yydebug など変数名を大幅変更
<li>文法ファイルの構造が class...rule...end に変わった
<li>コアのコードを一新、高速化
<li>strscan を併合
<li>ライブラリを racc/ ディレクトリに移動
</ul>

<hr>
<h2>0.9.5(1999/10/03)</h2>
<p>
thanks > Toshさん
<ul>
<li>0.9.4 の変更がすごくバグってた
<li>$end が通らなかったのを修正
<li>__show_stack__ の引数が違ってた
</ul>

<h2>0.9.4(1999/09/??)</h2>
<p>
<ul>
<li>Parser::Reporter をなくしてメソッドに戻した
<li>d.format.rb を再編成
</ul>

<h2>0.9.3(1999/09/03)</h2>
<p>
<ul>
<li>racc.rb -> racc
</ul>

<h2>0.9.2(1999/06/26)</h2>
<p>
<ul>
<li>strscan使用
</ul>

<h2>0.9.1(1999/06/08)</h2>
<p>
<ul>
<li>アクション中の正規表現に対応 ( /= にも注意だ)
<li>アクション中の # コメントに対応
</ul>

<h2>0.9.0(1999/06/03)</h2>
<p>
<ul>
<li>アクションを { } 形式にした
<li>ユーザーコードを '----' を使う形式にした
</ul>


<hr>

<h2>0.8.11</h2>
<p>
<ul>
<li>-g 出力をわかりやすくした
</ul>

<h2>0.8.10</h2>
<p>
<ul>
<li>アクションからreturnできるようにした
</ul>

<h2>0.8.9(1999/03/21)</h2>
<p>
<ul>
<li>-g + @__debug__をつかったデバッグメッセージ操作
<li>エラー発生時のバグを修正
<li>TOKEN_TO_S_TABLEを付加するようにした
</ul>

<h2>0.8.8(1999/03/20)</h2>
<p>
<ul>
<li>100倍程度の高速化
<li>defaultトークンを加えた
<li>デバッグ用ソースを出力するオプション-gをくわえた
<li>user_initializeを廃止し、普通にinitializeを使えるようにした
<li>parse_initialize/finalize,parseメソッドを廃止
<li>next_token,next_value,peep_tokenのデフォルトを廃止
<li>%precと同等の機能を加えた
</ul>

<h2>0.8.7(1999/03/01)</h2>
<p>
<ul>
<li>内部構造が大幅に変化
<li>マニュアルがHTMLになった
</ul>

<h2>0.8.0(1999/01/16)</h2>
<p>
なぜいきなり 0.8 ？？？
<ul>
<li>文法がブロック型に変化
</ul>

<h2>0.5.0(1999/01/07)</h2>
<p>
<ul>
<li>演算子優先順位が実装されたようだ
<li>スタート規則が実装されたようだ
<li>トークン値の置換が実装されたようだ(後に致命的なバグ発見)
</ul>

<h2>0.1.0(1999/01/01)</h2>
<p>
とにかく動くようになった

<% footer 1999 %>
