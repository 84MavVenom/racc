. file index.html -------------------------------------------------------
<% header 'Racc User Manual' %>

<h1>Racc user manual</h1>

<p>
updated for version 1.3.9

<p>
Racc は文法規則から Ruby で書かれたパーサを生成するパーサジェネレータです。
パーサ生成アルゴリズムには yacc などと同じ LALR(1) を使用しています。

<ul>
<li><a href="usage.html">Racc の使い方</a>
<li><a href="command.html">racc コマンドリファレンス</a>
<li><a href="grammer.html">規則ファイル文法リファレンス</a>
<li><a href="parser.html">Parser クラスリファレンス</a>
<li><a href="debug.html">デバッグ情報</a>
<li><a href="changes.html">変更履歴</a>
</ul>

<% footer 1999 %>
. file usage.html --------------------------------------------------------
<% header 'Usage' %>

<h1>Racc の使い方</h1>

<p>
racc は yacc を知っていることを前提にしていますので、もし知らないのな
ら先に yacc を勉強しましょう。いきなり racc を使うのは不可能です(これ
は断言できます)。…と書いていたのですが、C マガでごとけんさんに
<blockquote>
そんなことはないです。これは断言できます
</blockquote>
と書かれてしまったので筆者ももう少しねばってみます。しかしやっぱり初歩
から親切丁寧というわけにはいかないので、詳しくは 2001 年 2 月末発売の
「Ruby を 256 倍使う本 無道編」(青木峰郎著、ASCII) を読んでください。

<h2>Racc とはなにか</h2>
<p>
Racc は文法を処理するツールです。<br>
文字列はただの文字の列で、コンピュータにとっては意味を持ちません。しかし
人間はその文字の列の中になにか意味を見出すことができます。コンピュー
タにもそのようなことを、部分的にでも、させられたら便利でしょう。Racc は
その手伝いをしてくれます。完全な自動化ではありませんが、人間が全部やるよ
りも遥かに簡単な手段で可能になります。
<p>
その、Racc が自動化してくれる部分とは、文字列の含む「構造」の処理です。
たとえば Ruby の if 文を考えてみると、次のように定式化できます。
<blockquote><pre>
if 条件式 [then]
  文
  ：
[elsif 条件式 [then]
  文
  ：]
[else
  文
  ：]
end
</pre></blockquote>
if 文では if という単語が最初になくてはならず、elsif 節は else 節より
前になくてはいけません。このような配置の関係(構造)が、Racc で処理でき
るものです。
<p>
一方、Racc で処理できないのはどういうことでしょうか。それは、たとえば
if の条件式にあたる部分が「なんであるか」ということです。つまり、条件
式が if の条件だということです。これは、こっちで条件として扱うコードを
書いてやらないといけません。
<p>
と言っても、わかりにくいでしょう。こういう抽象的なものは実際にいじって
みるのが一番です。

<h2>実際の話</h2>
<p>
実際に Racc をどのように使うかという話をします。Racc には独自のソース
コードみたいなものがあって、この中に処理したい「構造」を記述しておきま
す。このソースファイルを「文法ファイル」と呼ぶことにしましょう。この文
法ファイルの名前が parse.y と仮定すると、コマンドラインから以下のよう
に打ちこめば、その構造を処理するためのクラスを含んだファイルが得られま
す。

<blockquote><pre>
$ racc parse.y
</pre></blockquote>

生成されるファイルはデフォルトでは "ファイル名.tab.rb" です。他の名前
にしたいなら、-o オプションで変更できます。

<blockquote><pre>
$ racc parse.y -o myparser.rb
</pre></blockquote>

このようにして作ったクラス、またはそのような処理を担当するパート、のこ
とはパーサ(parser)と呼ぶことになっています。解析するヤツ、っていうくら
いに適当にとらえてください。

<h2>文法ファイルを書く</h2>
<p>
Racc は文法ファイルから Ruby のクラスを生成するツールだと言いました。
そのクラスは全て Racc::Parser の下位クラスで、名前は文法ファイル中で
指定します。以下、ここに書くべきことが「なんなのか」を説明します。
ここでは内容に重点を置くので、文法ファイル自体の文法の詳細は
<a href="grammer.html">文法リファレンス</a>
を見てください。

<h3>文法</h3>
<p>
まずは、全体の概形です。

<blockquote><pre>
class MyParser
rule

  if_stmt: IF expr then stmt_list elsif else END

  then   : THEN
         |

  elsif  :
         | ELSIF stmt_list

  else   :
         | ELSE stmt_list

  expr   : NUMBER
         | IDENT
         | STRING

  stmt_list : ふにゃふにゃ

end
</pre></blockquote>

Ruby スクリプトのように class でパーサクラス名を指定し、rule ... end 
の間にパーサに解析させたい文法を記述します。
<p>
文法は、記号の並びでもって表します。rule ... end の間にあるコロンとバー
以外のもの、if_stmt IF expr then などが全て「記号」です。そしてコロン
が日本語で言う「〜は××だ」の「は」みたいなもんで、その左の記号が右の
記号の列と同じものを指す、というふうに定義します。また、バーは「または」
を意味します。それと、単純にコロンの左の記号のことを左辺、右を右辺とも
言います。以下はこちらのほうを使って説明しましょう。
<p>
少し注意が必要な点を述べます。まず、then の、バーのあとの定義(規則)を
見てください。ここには何も書いていないので、これはその通り「無」であっ
てもいい、ということを表しています。つまり、then は記号 THEN 一個か、
またはなにもなし(省略する)でよい、ということです。記号 then は実際の 
Ruby のソースコードにある then とは切り離して考えましょう(それは実は大
文字の記号 THEN が表しています)。
<p>
さて、そろそろ「記号」というものがなんなのか書きましょう。
ただし順番に話をしないといけないので、まずは聞いていてください。
この文章の最初に、パーサとは文字の列から構造を見出す部分だと言いました。
しかし文字の列からいきなり構造を探すのは面倒なので、実際にはまず
文字の列を単語の列に分割します。その時点でスペースやコメントは捨てて
しまい、以降は純粋にプログラムの一部をなす部分だけを相手にします。
たとえば文字列の入力が次のようだったとすると、

<blockquote><pre>
if flag then   # item found.
  puts 'ok'
end
</pre></blockquote>

単語の列は次のようになります。

<blockquote><pre>
if flag then puts 'ok' end
</pre></blockquote>

ここで、工夫が必要です。どうやら flag はローカル変数名だと思われますが、
変数名というのは他にもいろいろあります。しかし名前が i だろうが a だろ
うが vvvvvvvvvvvv だろうが、「構造」は同じです。つまり同じ扱いをされる
べきです。変数 a を書ける場所なら b も書けなくてはいけません。だったら
一時的に同じ名前で読んでもいいじゃん。ということで、この単語の列を以下
のように読みかえましょう。

<blockquote><pre>
IF IDENT THEN IDENT STRING END
</pre></blockquote>

これが「記号」の列です。パーサではこの記号列のほうを扱い、構造を見付け
ていきます。
<p>
さらに記号について見ていきましょう。
記号は二種類に分けられます。「左辺にある記号」と「ない記号」です。
左辺にある記号は「非終端」記号と言います。ないほうは「終端」記号と
言います。最初の例では終端記号はすべて大文字、非終端記号は小文字で
書いてあるので、もう一度戻って例の文法を見てください。
<p>
なぜこの区分が重要かと言うと、入力の記号列はすべて終端記号だからです。
一方、非終端記号はパーサの中でだけ、終端記号の列から「作りだす」ことに
よって始めて存在します。例えば次の規則をもう一度見てください。

<blockquote><pre>
  expr   : NUMBER
         | IDENT
         | STRING
</pre></blockquote>

expr は NUMBER か IDENT か STRING だと言っています。逆に言うと、
IDENT は expr に「なることができます」。文法上 expr が存在できる
場所に IDENT が来ると、それは expr になります。例えば if の条件式の
部分は expr ですから、ここに IDENT があると expr になります。その
ように文法的に「大きい」記号を作っていって、最終的に一個になると、
その入力は文法を満たしていることになります。実際にさっきの入力で
試してみましょう。入力はこうでした。

<blockquote><pre>
IF IDENT THEN IDENT STRING END
</pre></blockquote>

まず、IDENT が expr になります。

<blockquote><pre>
IF expr THEN IDENT STRING END
</pre></blockquote>

次に THEN が then になります。

<blockquote><pre>
IF expr then IDENT STRING END
</pre></blockquote>

IDENT STRING がメソッドコールになります。この定義はさきほどの例には
ないですが、実は省略されているんだと考えてください。そしていろいろな
過程を経て、最終的には stmt_list (文のリスト)になります。

<blockquote><pre>
IF expr then stmt_list END
</pre></blockquote>

elsif と else は省略できる、つまり無から生成できます。

<blockquote><pre>
IF expr then stmt_list elsif else END
</pre></blockquote>

最後に if_stmt を作ります。

<blockquote><pre>
if_stmt
</pre></blockquote>

ということでひとつになりました。つまりこの入力は文法的に正しい入力です。

<h3>アクション</h3>
<p>
ここまでで入力の文法が正しいかどうかを確認する方法はわかりましたが、
これだけではなんにもなりません。最初に説明したように、ここまででは
構造が見えただけで、プログラムは「意味」を理解できません。そしてその
部分は Racc では自動処理できないので、人間が書く、とも言いました。
それを書くのが以下に説明する「アクション」という部分です。
<p>
前項で、記号の列がだんだんと大きな単位にまとめられていく過程を見ました。
そのまとめる時に、同時になにかをやらせることができます。それが
アクションです。アクションは、文法ファイルで以下のように書きます。

<blockquote><pre>
class MyParser
rule

  if_stmt: IF expr then stmt_list elsif else END
             { puts 'if_stmt found' }

  then   : THEN
             { puts 'then found' }
         |
             { puts 'then is omitted' }

  elsif  :
             { puts 'elsif is omitted' }
         | ELSIF stmt_list
             { puts 'elsif found' }

  else   :
             { puts 'else omitted' }
         | ELSE stmt_list
             { puts 'else found' }

  expr   : NUMBER
             { puts 'expr found (NUMBER)' }
         | IDENT
             { puts 'expr found (IDENT)' }
         | STRING
             { puts 'expr found (STRING)' }

  stmt_list : ふにゃふにゃ

end
</pre></blockquote>

見てのとおり、規則のあとに { と } で囲んで書きます。
アクションにはだいたい好きなように Ruby スクリプトが書けます。

<p>
(このドキュメントはまだ不完全です。続きはこれから書きます)
<hr>

<p>
yacc での <code>$$</code> は Racc ではローカル変数 <code>result</code>
で、<code>$1,$2...</code> は配列 <var>val</var>です。
<code>result</code> は <code>val[0]</code> ($1) の値に初期化され、アク
ションを抜けたときの <code>result</code> の値が左辺値になります。Racc 
ではアクション中の <code>return</code> はアクションから抜けるだけで、
パース自体は終わりません。アクション中からパーズを終了するには、メソッ
ド <code>yyaccept</code> を使ってください。
<p>
演算子の優先順位、スタートルールなどの yacc の一般的な機能も用意されて
います。ただしこちらも少し文法が違います。
<p>
yacc では生成されたコードに直接転写されるコードがありました。Racc でも
同じように、ユーザ指定のコードが書けます。racc ではクラスを生成するの
で、クラス定義の前/中/後の三個所があります。Racc ではそれを上から順番
に header inner footer と呼んでいます。

<h3>ユーザが用意すべきコード</h3>
<p>
パースのエントリポイントとなるメソッドは二つあります。ひとつは 
<code>do_parse</code>で、こちらはトークンを 
<code>Parser#next_token</code> から得ます。もうひとつは 
<code>yyparse</code> で、こちらはスキャナから <code>yield</code> され
ることによってトークンを得ます。ユーザ側ではこのどちらか(両方でもいい
けど)を起動する簡単なメソッドを inner に書いてください。これらメソッド
の引数など、詳しいことはリファレンスを見てください。
<ul>
<li><a href="parser.html#do_parse">do_parse</a>
<li><a href="parser.html#yyparse">yyparse</a>
</ul>
<p>
どちらのメソッドにも共通なのはトークンの形式です。必ずトークンシンボル
とその値の二要素を持つ配列を返すようにします。またスキャンが終了して、
もう送るものがない場合は <code>[false,<var>なにか</var]</code> を返し
てください。これは一回返せば十分です (逆に、<code>yyparse</code> を使
う場合は二回以上 <code>yield</code> してはいけない)。
<p>
パーザは別に文字列処理にだけ使われるものではありませんが、実際問題とし
て、パーザを作る場面ではたいてい文字列のスキャナとセットで使うことが多
いでしょう。Ruby ならスキャナくらい楽勝で作れますが、高速なスキャナと
なると実は難しかったりします。そこで高速なスキャナを作成するためのライ
ブラリも作っています。詳しくは
<a href="#scanner">「スキャナを作る」の項</a>を見てください。
<p>
Racc には error トークンを使ったエラー回復機能もあります。yacc の
<code>yyerror()</code> は Racc では
<a href="parser.html"><code>Parser#on_error</code></a> で、エラーが
おきたトークンとその値、値スタック、の三つの引数をとります。
<code>on_error</code> はデフォルトでは例外 <code>ParseError</code> を
発生するようになっています。
<p>
ユーザがアクション中でパースエラーを発見した場合は、メソッド
<code>yyerror</code>を呼べばパーサがエラー回復モードに入ります。ただし
このときは <code>on_error</code>は呼ばれないので、なにか報告をしたい時
はユーザが明示的に <code>on_error</code> を呼んだりする必要があります。

<h3>パーザを生成する</h3>
<p>
これだけあればだいたい書けると思います。あとは、最初に示した方法で文法
ファイルを処理し、Ruby スクリプトを得ます。
<p>
うまくいけばいいのですが、大きいものだと最初からはうまくいかないでしょ
う。racc に -g オプションをつけてコンパイルし、@yydebug を true にする
とデバッグ用の出力が得られます。デバッグ出力はパーザの @racc_debug_out 
に出力されます(デフォルトは stderr)。また、racc に -v オプションをつけ
ると、状態遷移表を読みやすい形で出力したファイル(*.output)が得られます。
どちらもデバッグの参考になるでしょう。


<h2>作ったパーザを配布する</h2>
<p>
Racc の生成したパーザは動作時にランタイムルーチンが必要になります。具
体的には parser.rb と cparse.so です。ただし cparse.so は単にパースを
高速化するためにあり、必須ではありません。これらのファイルを自分でセッ
トアップするのはなかなか面倒です。Racc をユーザみんなにインストールし
てもらうのも一つの手ですが、これでは不親切です。そこでRacc では回避策
を用意しました。

<p>
racc に -E オプションをつけてコンパイルすると必要なものを全部結合した
ファイルが得られます。これだとファイルはひとつだけなので扱いが楽です
(この形式のパーサのファイルが複数あったとしてもクラスやメソッドが衝突
することはありません)。ただし cparse.so が使えませんので、必然的に動作
は全て Ruby スクリプトレベルで行われ、速度は低下します。ただしこれにも
例外があって、配布先に既に Racc ランタイムがあるときは自動的にそちらが
使われます。


<h2><a name="scanner">おまけ：スキャナを作る</a></h2>
<p>
パーサを使うときは、たいてい文字列をトークンに切りわけてくれるスキャナ
が必要になります。しかし実は Ruby は文字列の最初からトークンに切りわけ
ていくという作業があまり得意ではありません。正確に言うと、簡単にできる
のですが、非常に大きいオーバーヘッドがかかります。
<p>
そのオーバーヘッドを回避しつつ、手軽にスキャナをつくれるように strscan 
というパッケージを同梱しています。ドキュメントなどは
<a href="http://www1.u-netsurf.ne.jp/~brew/mine/ja/">
筆者のホームページ</a>から取れるので、試してみてください。

<% footer 1999 %>
. file command.html -----------------------------------------------------------
<% header 'Racc Command' %>

<h1>Raccコマンドリファレンス</h1>

<hr>

<p>
racc [-o<var>filename</var>] [--output-file=<var>filename</var>]
     [-e<var>rubypath</var>] [--embedded=<var>rubypath</var>]
     [-v] [--verbose]
     [-O<var>filename</var>] [--log-file=<var>filename</var>]
     [-g] [--debug]
     [-E] [--embedded]
     [-l] [--no-line-convert]
     [-c] [--line-convert-all]
     [-s<var>classname</var>] [--super=<var>classname</var>]
     [-r<var>filename</var>] [--runtime=<var>filename</var>]
     [-a] [--no-omit-actions]
     [-C] [--check-only]
     [-S] [--output-status]
     [--version] [--copyright] [--help] <var>grammerfile</var>
</p>

<dl>
<dt><var>grammerfile</var>
<dd>
Raccの文法ファイルを指定します。拡張子には特に制限はありません。

<dt>-o<var>outfile</var>, --output-file=<var>outfile</var>
<dd>
作成するクラスをかきこむファイル名を指定します。デフォルトは<filename>.tab.rbです。

<dt>-e<var>rubypath</var>, --executable=<var>rubypath</var>
<dd>
実行可能ファイルを生成します。<var>rubypath</var>は Ruby 本体のパスです。
<var>rubypath</var>を単に 'ruby' にした時には Racc が動作している
Ruby のパスを使用します。

<dt>-v, --verbose
<dd>
ファイル "filename".output に詳細な解析情報を出力します。

<dt>-O<var>filename</var>, --log-file=<var>filename</var>
<dd>
-v オプションをつけた時に生成するログファイルの名前を
<var>filename</var> に変更します。デフォルトは "filename".output です。

<dt>-g, --debug
<dd>
出力するコードにデバッグ用コードを加えます。-g をつけて生成したパーサで
@yydebug を true にセットすると、デバッグ用のコードが出力されます。<br>
-g をつけるだけでは何もおこりませんので注意してください。

<dt>-E, --embedded
<dd>
ランタイムルーチンをすべて含んだコードを生成します。
つまり、このオプションをつけて生成したコードは Ruby さえあれば動きます。

<dt>-l, --no-line-convert
<dd>
Ruby では例外が発生した時のファイル名や行番号を表示してくれますが、
Racc の生成したパーサは、デフォルトではこの場合のファイル名・行番号を
文法ファイルでのものに置きかえます。このフラグはその機能をオフにします。
<p>
ruby 1.4.3 以前のバージョンではバグのために定数の参照に失敗する
場合があるので、定数参照に関してなにかおかしいことがおこったらこのフラグを
試してみてください。

<dt>-c, --line-convert-all
<dd>
アクションと inner に加え header footer の行番号も変換します。
header と footer がつながっているような場合には使わないでください。

<dt>-s<var>classname</var>, --super=<var>classname</var>
<dd>
パーサのスーパークラスを Racc::Parser から <var>classname</var> に
変更します。

<dt>-r<var>filename</var>, --runtime=<var>filename</var>
<dd>
require あるいは埋めこむランタイムファイルを racc/parser から
<var>filename</var>に変更します。

<dt>-a, --no-omit-actions
<dd>
全てのアクションに対応するメソッド定義と呼び出しを行います。
例えアクションが省略されていても空のメソッドを生成します。

<dt>-C, --check-only
<dd>
(文法ファイルの)文法のチェックだけをして終了します。

<dt>-S, --output-status
<dd>
進行状況を逐一報告します。

<dt>--version
<dd>
Racc のバージョンを出力して終了します。

<dt>--copyright
<dd>
著作権表示を出力して終了します。

<dt>-h, --help
<dd>
オプションの簡単な説明を出力して終了します。

</dl>

<% footer 1999 %>
. file grammer.html -----------------------------------------------------
<% header 'Grammer Reference' %>

<h1>規則ファイル文法リファレンス</h1>

<hr>

<h2>文法に関する前バージョンとの非互換</h2>
<ul>
<li>(1.2.5) ユーザーコードを連結する時、外部ファイルよりも
            埋めこんであるコードを先に連結します。
<li>(1.1.6) 新しいディレクティブ options が追加されました。
<li>(1.1.5) 予約語 token の意味が変更になりました。
<li>(0.14) ルールの最後のセミコロンが省略可能になりました。
           また、token prechigh などが予約語でなくなりました。
<li>(10.2) prepare が header に driver が footer になりました。
           今はそのままでも使えますが、2.0 からは対応しません。
<li>(0.10) class に対応する end がなくなりました。
<li>(0.9) ダサダサのピリオド方式をやめて { と } で囲むようにしました。
</ul>


<h2><a name="whole">全体の構造</a></h2>

<p>
トップレベルは、規則部とユーザーコード部に分けられます。
ユーザーコード部はクラス定義の後に来なければいけません。


<h3><a name="comment">コメント</a></h3>

<p>
文法ファイルには、一部例外を除いて、ほとんどどこにでもコメントを
書くことができます。コメントは、Rubyの #.....(行末) スタイルと、
Cの /*......*/ スタイルを使うことができます。


<h3><a name="class">規則部</a></h3>

<p>
規則部は以下のような形をしています。
<pre>

    class クラス名 [< スーパークラス]
      [演算子順位]
      [トークン宣言]
      [オプション]
      [expect]
      [トークンシンボル値おきかえ]
      [スタート規則]
    rule
      文法記述
    end

</pre>
"クラス名"はここで定義するパーサクラスの名前です。
これはそのままRubyのクラス名になります。

<p>
また M::C のように「::」を使った名前を使うと、クラス定義を
モジュール M の中にネストさせます。つまり class M::C ならば
<blockquote><pre>
module M
  class C < Racc::Parser
    いろいろ
  end
end
</pre></blockquote>
のように出力します。
<p>
さらに、Ruby と同じ構文でスーパークラスを指定できます。
ただしこの指定をするとパーサの動作に重大な影響を与えるので、
特に必要がない限り指定してはいけません。これは将来の拡張の
ために用意したもので、現在指定する必然性はあまりありません。


<h4><a name="grammer">文法の記述</a></h4>
<p>
racc で生成するパーサが理解できる文法を記述します。
文法は、予約語 rule と end の間に、以下のような書式で書きます。
<blockquote><pre>
トークン: トークンの並び アクション

トークン: トークンの並び アクション
        | トークンの並び アクション
        | トークンの並び アクション
             (必要なだけ同じようにつづける)
</pre></blockquote>
アクションは { } で囲みます。アクションでは Ruby の文はほとんど
使えますが、一部だけは非対応です。対応していないものは以下のとおり。
<ul>
<li>ヒアドキュメント
<li>=begin ... =end 型コメント
<li>スペースで始まる正規表現
<li>ごくまれに % の演算。普通に演算子のまわりにスペースを入れていれば問題なし
</ul>
このあたりに関しては完全な対応はまず無理です。あきらめてください。
<p>
左辺の値($$)は、オプションによって返し方がかわります。まずデフォルトでは
ローカル変数 result (そのデフォルト値は val[0])が 左辺値を表し、アクション
ブロックを抜けた時の result の値が左辺値になります。または明示的に return
で返した場合もこの値になります。一方、options で no_result_var を指定した
場合、左辺値はアクションブロックの最後の文の値になります (Ruby のメソッドと
同じ)。
<p>
どちらの場合でもアクションは省略でき、省略した場合の左辺値は常に val[0] です。
<p>
以下に文法記述の全体の例をしめします。
<blockquote><pre>
rule

  goal: def ruls source
        {
          result = val
        }

  def : /* none */
        {
          result = []
        }
      | def startdesig
        {
          result[0] = val[1]
        }
      | def
          precrule   # これは上の行の続き
        {
          result[1] = val[1]
        }
(略)
end  # endで規則部終了
</pre></blockquote>
アクション内では特別な意味をもった変数がいくつか使えます。
そのような変数を以下に示します。括弧の中は yacc での表記です。
<dl>
<dt>result ($$)
<dd>
左辺の値。初期値は val[0] です。

<dt>val ($1,$2,$3…)
<dd>
右辺の記号の値の配列。Ruby の配列なので当然インデックスはゼロから始まります。
この配列は毎回作られるので自由に変更したり捨てたりして構いません。

<dt>_values (...,$-2,$-1,$0)
<dd>
値スタック。Racc コアが使っているオブジェクトがそのまま渡されます。
この変数の意味がわかる人以外は<em>絶対に</em>変更してはいけません。

</dl>
<p>
またアクションの特別な形式に、埋めこみアクションというものがあります。
これはトークン列の途中の好きなところに記述することができます。
以下に埋めこみアクションの例を示します。
<blockquote><pre>
target: A B { puts 'test test' } C D { normal action }
</pre></blockquote>
このように記述すると A B を検出した時点で puts が実行されます。
また、埋めこみアクションはそれ自体が値を持ちます。つまり、以下の例において
<blockquote><pre>
target: A { result = 1 } B { p val[1] }
</pre></blockquote>
最後にある p val[1] は埋めこみアクションの値 1 を表示します。
B の値ではありません。
<p>
意味的には、埋めこみアクションは空の規則を持つ非終端記号を追加することと
全く同じ働きをします。つまり、上の例は次のコードと完全に同じ意味です。
<blockquote><pre>
target  : A nonterm B { p val[1] }
nonterm : /* 空の規則 */ { result = 1 }
</pre></blockquote>


<h4><a name="prec">演算子優先順位</a></h4>
<p>
あるトークン上でシフト・還元衝突がおこったとき、そのトークンに
演算子優先順位が設定してあると衝突を解消できる場合があります。
そのようなものとして特に有名なのは数式の演算子と if...else 構文です。
<p>
優先順位で解決できる文法は、うまく文法をくみかえてやれば
優先順位なしでも同じ効果を得ることができます。しかしたいていの
場合は優先順位を設定して解決するほうが文法を簡単にできます。
<p>
シフト・還元衝突がおこったとき、Racc はまずその規則に順位が設定
されているか調べます。規則の順位は、その規則で一番うしろにある
終端トークンの優先順位です。たとえば
<blockquote><pre>
target: TERM_A nonterm_a TERM_B nonterm_b
</pre></blockquote>
のような規則の順位はTERM_Bの優先順位になります。もしTERM_Bに
優先順位が設定されていなかったら、優先順位で衝突を解決することは
できないと判断し、「Shift/Reduce conflict」を報告します。
<p>
演算子の優先順位はつぎのように書いて定義します。
<blockquote><pre>
prechigh
  nonassoc PLUSPLUS
  left     MULTI DEVIDE
  left     PLUS MINUS
  right    '='
preclow
</pre></blockquote>
prechigh に近い行にあるほど優先順位の高いトークンです。上下をまるごと
さかさまにして preclow...prechigh の順番に書くこともできます。left
などは必ず行の最初になければいけません。
<p>
left right nonassoc はそれぞれ「結合性」を表します。結合性によって、
同じ順位の演算子の規則が衝突した場合にシフト還元のどちらをとるかが
決まります。たとえば
<blockquote><pre>
a + b + c
</pre></blockquote>
が
<blockquote><pre>
(a + b) + c
</pre></blockquote>
になるのが左結合(left)です。四則演算は普通これです。一方
<blockquote><pre>
a + (b + c)
</pre></blockquote>
になるのが右結合(right)です。代入のクオートは普通 right です。
またこのように演算子が重なるのはエラーである場合、非結合(nonassoc)です。
C 言語の ++ や単項のマイナスなどがこれにあたります。
<p>
ところで、説明したとおり通常は還元する規則の最後のトークンが順位を
決めるのですが、ある規則に限ってそのトークンとは違う順位にしたいことも
あります。例えば符号反転のマイナスは引き算のマイナスより順位を高く
しないといけません。このような場合 yacc では %prec を使います。
racc ではイコール記号を使って同じことをできます。
<pre>
prechigh
  nonassoc UMINUS
  left '*' '/'
  left '+' '-'
preclow
(略)
exp: exp '*' exp
   | exp '-' exp
   | '-' exp     = UMINUS    # ここだけ順位を上げる
</pre>
このように記述すると、'-' exp の規則の順位が UMINUS の順位になります。
こうすることで符号反転の '-' は '*' よりも順位が高くなるので、
意図どおりになります。


<h4><a name="token">トークン宣言</a></h4>
<p>
トークン(終端記号)のつづりを間違えるというのはよくあることですが、
発見するのはなかなか難しいものです。1.1.5 からはトークンを明示的に
宣言することで、宣言にないトークン / 宣言にだけあるトークンに対して
警告が出るようになりました。yacc の %token と似ていますが最大の違いは
racc では必須ではなく、しかもエラーにならず警告だけ、という点です。
<p>
トークン宣言は以下のように書きます。
<blockquote><pre>
token A B C D
        E F G H
</pre></blockquote>
トークンのリストを複数行にわたって書けることに注目してください。
racc では一般に「予約語」は行の先頭に来た時だけ予約語とみなされるので
prechigh などもシンボルとして使えます。ただし深淵な理由から end だけは
どうやっても予約語になってしまいます。


<h4>オプション</h4>
<p>
racc のコマンドラインオプションの一部をファイル中にデフォルト値
として記述することができます。
<pre>
options オプション オプション …
</pre>
現在ここで使えるのは
<dl>
<dt>omit_action_call <dd>空のアクション呼び出しを省略する
<dt>result_var       <dd>変数 result を使う
</dl>
です。それぞれ no_ を頭につけることで意味を反転できます。


<h4><a name="expect">expect</a></h4>
<p>
実用になるパーサはたいてい無害な shift/reduce conflict を含みます。
しかし文法ファイルを書いた本人はそれを知っているからいいですが、
ユーザが文法ファイルを処理した時に「conflict」と表示されたら
不安に思うでしょう。そのような場合、以下のように書いておくと
shift/reduce conflict のメッセージを抑制できます。
<blockquote><pre>
expect 3
</pre></blockquote>
この場合 shift/reduce conflict はぴったり三つでなければいけません。
三つでない場合はやはり表示が出ます (ゼロでも出ます)。
また reduce/reduce conflict の表示は抑制できません。


<h4><a name="convert">トークンシンボル値の変更</a></h4>
<p>
トークンシンボルを表す値は、デフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの(RULEとかXENDとか)<br>
    →その名前の文字列を intern して得られるシンボル(1.4 では Fixnum)
<li>引用符でかこまれているもの(':'とか'.'とか)<br>
    →その文字列そのまま
</ul>
<p>
となっていますが、たとえば他の形式のスキャナがすでに存在する場合などは、
これにあわせなければならず、このままでは不便です。このような場合には、
convert 節を加えることで、トークンシンボルを表す値を変えることができます。
以下がその例です。
<blockquote><pre>
convert
  PLUS 'PlusClass'      #→ PlusClass
  MIN  'MinusClass'     #→ MinusClass
end
</pre></blockquote>
デフォルトではトークンシンボル PLUS に対してはトークンシンボル値は
:PLUS ですが、上のような記述がある場合は PlusClass になります。
変換後の値は false・nil 以外ならなんでも使えます。
<p>
変換後の値として文字列を使うときは、次のように引用符を重ねる必要があります。
<blockquote><pre>
convert
  PLUS '"plus"'       #→ "plus"
end
</pre></blockquote>
<p>
また、「'」を使っても生成された Ruby のコード上では「"」になるので
注意してください。バックスラッシュによるクオートは有効ですが、バック
スラッシュは消えずにそのまま残ります。
<em>これは仕様です。バグではありません。</em>
<pre>
PLUS '"plus\n"'          #→ "plus\n"
MIN  "\"minus#{val}\""   #→ \"minus#{val}\"
</pre>


<h4><a name="start">スタート規則</a></h4>
<p>
パーサをつくるためには、どの規則が「最初の」規則か、ということを Racc におしえて
やらなければいけません。それを明示的に書くのがスタート規則です。スタート規則は
次のように書きます。
<blockquote><pre>
start real_target
</pre></blockquote>
start は行の最初にこなければいけません。このように書くと、ファイルで
一番最初に出てくる real_target の規則をスタート規則として使います。
省略した場合は、ファイルの最初の規則がスタート規則になります。普通は
最初の規則を一番上にかくほうが書きやすく、わかりやすくなりますから、
この記法はあまりつかう必要はないでしょう。


<h3><a name="usercode">ユーザーコード部</a></h3>
<p>
ユーザーコードは、パーサクラスが書きこまれるファイルに、
アクションの他にもコードを含めたい時に使います。このようなものは
書きこまれる場所に応じて三つ存在し、パーサクラスの定義の前が
header、クラスの定義中(の冒頭)が inner、定義の後が footer です。
ユーザコードとして書いたものは全く手を加えずにそのまま連結されます。
<p>
ユーザーコード部の書式は以下の通りです。
<blockquote><pre>
---- 識別子
  ruby の文
  ruby の文
  ruby の文

---- 識別子
  ruby の文
     :
</pre></blockquote>
行の先頭から四つ以上連続した「-」(マイナス)があるとユーザーコードと
みなされます。識別子は一つの単語で、そのあとには「=」以外なら何を
書いてもかまいません。
<p>
また、次のような文で外部ファイルをユーザーコードとしてインクルード
することもできます。
<blockquote><pre>
---- 識別子 = ファイル名 ファイル名 ファイル名 .....
</pre></blockquote>
以下はこの記述を使った例です。
<blockquote><pre>
---- footer = init.rb err.rb run.rb

print "this line is added, too\n"
</pre></blockquote>
ここでは init.rb err.rb run.rb の三つを footer コードとして指定しています。
こうするとまず ---- のある行の下に書いたもの(print のある行など)が連結され、
その後にこれら三つのファイルの中身が連結されます(この順番は 1.2.5 から)。
さきほど ---- のある行の識別子のあとはなにを書いてもいいと言いましたが、
外部ファイルを指定する場合はなにも書くことができません。コメントもだめです。
正確にファイル名だけをならべて書いてください。
<p>
またほとんどの人には関係ないことですが、いちおうつけくわえます。
上に書いたような順番からすると、最終的な全体像は次のようになります。
<blockquote><pre>
# header
# 外部 header
class MyParser < Racc::Parser
  # inner
  # 外部 inner
  # パーサコア
end
# footer
# 外部 footer
</pre></blockquote>
ここから、もし header と footer を使ってパーサをモジュールの中に
ネストさせていてしかも外部 header がそのモジュールの外で定義
されるべきである場合、問題が起きます。具体的には以下のような場合です。
<pre>
(mondai.y)

class MyParser
rule
  いろいろする
end
---- header = mypar.head
module MyMod
---- footer
end


(mypar.head)

module MyMod
  class HelperClass
    いろいろする
  end
end

</pre>
この場合、mypar.head が header の module MyMod の後に来てしまうので
HelperClass は ::MyMod::MyMod::HelperClass になってしまいます。
これはおそらく意図と違うはずです。

<% footer 1999 %>
. file parser.html ------------------------------------------------
<% header 'Parser' %>

<h1><a name="parser">Racc::Parserクラス</a></h1>
<p>
Racc の生成するパーサはすべて <code>Parser</code> クラスを継承します。
<code>Parser<code> クラスにはパース中に使用するメソッドがいくつかあり、
そのようなメソッドをオーバーロードすると、パーサの初期化などができます。
逆に言うと、これらのメソッドを変に再定義すると挙動がおかしく
なるわけですから注意してください。

<h2>スーパークラス</h2>
<p>
Object

<h2>定数</h2>
<p>
プリフィックス "Racc_" がついた定数はパーサの予約定数です。
そのような定数は使わないでください。動作不可能になります。

<h2>メソッド</h2>
<p>
ここに載っているもののほか、プリフィクス "racc_" および "_racc_" が
ついたメソッドはパーサの予約名です。そのようなメソッドは使わないで
ください。

<dl>
<dt><a name="do_parse"><code>do_parse</code></a>
<dd><p>
このメソッドを呼ぶことによってパースが開始します。また、トークンが必要
になった時は <code>next_token</code> を呼び出します。

<dt><a name="next_token"><code>next_token</code></a> [abstract]
<dd><p>
パーサが次のトークンを読みこむ時に使います。[記号, その値]の形式の配列
を返してください。記号はデフォルトでは
<ul>
<li>文法中、引用符でかこまれていないもの<br>
    →その名前の文字列のシンボル (たとえば <code>:ATOM</code> )
<li>引用符でかこまれているもの<br>
    →その文字列そのまま(たとえば、<code>'='</code>)
</ul>
で表します。これを変更する方法については、
<a href="grammer.html#token">文法リファレンス</a>を参照してください。
<p>
また、もう送るシンボルがなくなったときには <code>[false, なにか]
</code> を返してください。これを忘れるとわけのわからないパースエラーに
なります (一回送れば十分です)。ただし 1.3.7 からは試験的に 
<code>nil</code> も終端として認めるようにしています。
<p>
このメソッドは抽象メソッドなので <code>do_parse</code> を使う場合は
<em>必ず</em>下位クラスで再定義する必要があります。定義しないままパー
スを始めると例外 <code>NotImplementedError</code> が発生します。

<dt><a name="yyparse"><code>yyparse( <var>recv</var>, <var>mid</var> )</code></a>
<dd><p>
このメソッドを呼ぶことによってパースが開始します。このメソッドでは始め
てトークンが必要になった時点で <var>recv</var> に対して <var>mid</var> 
メソッドを呼び出し、そのブロックからトークンを得ます。つまり 
<code>recv#mid</code>というメソッドを用意して 
<code>yyparse(recv,mid)</code> とすれば <code>recv#mid</code> からトー
クンを <code>yield</code> して渡すことができます。<code>yield</code> 
するのは <code>next_token</code> と同じ形式の [記号, 値] です。さらに
このような動作は Ruby の <code>yield</code> の特性から

<blockquote><pre>
yield 記号, 値
</pre></blockquote>

と書けます。いちおう書いておくと

<blockquote><pre>
yield [記号, 値]
</pre></blockquote>

は意図したのとは違って

<blockquote><pre>
yield()[記号, 値]
</pre></blockquote>

になります。
<p>
少し注意が必要なのは、<code>recv#mid</code> が呼び出されるのは始めてトー
クンが必要になった時点であるということで、つまりその時点でもうパースが
進行中だということです。よって <code>recv#mid</code> の最初でパースの
初期化をするとうまくいかない場合があります。それから、トークンの終端を
示す<code>[false, なにか]</code> を渡したらそれ以上は 
<code>yield</code> しないでください。その場合には例外が発生します。
<p>
さらにさらに言うと、<code>recv#mid</code> では必ず <code>yield</code> 
してください。しない場合は何が起きても責任持てません。

<dt><a name="on_error"><code>
    on_error( <var>err_tok</var>, <var>err_val</var>, <var>_values</var> )
    </code></a>
<dd><p>
パーサコアが文法エラーを検出するとよびだします(yacc での
<code>yyerror</code>)。エラーメッセージを出すなり、例外を発生するなり
してください。このメソッドからもどったあとは、パーサはエラー回復モード
に移行します。
<p>
引数は、<var>err_tok</var> がパースエラーをおこした記号(の内部表現の整
数)、<var>err_val</var> がその値、<var>_values</var> はその時点の値ス
タックです。<var>err_tok</var> は <code>token_to_str</code> で文法ファ
イル上の表現に直せます。また <code>_values</code> を変更してはいけません。
<p>
デフォルトでは例外 <code>ParseError</code> を発生します。

<dt><a name="token_to_str"><code>token_to_str( <var>t</var> )</a></code>
<dd><p>
Racc トークンの内部表現(整数)を文法ファイル上の記号表現の文字列に変換
します。<var>t</var> が整数でない場合は <code>NameError</code> を発生
します。<var>t</var> が範囲外の整数だった場合は <code>nil</code> を返
します。

<dt><a name="yyerror"><code>yyerror</code></a>
<dd><p>
エラー回復モードに入ります。このとき <code>on_error</code> は呼ばれません。
アクション以外からは呼び出さないでください。

<dt><a name="yyerrok">yyerrok</a>
<dd><p>
エラー回復モードから復帰します。アクション以外からは呼び出さないでくだ
さい。

<dt><a name="yyaccept">yyaccept</a>
<dd>
すぐに値スタックの先頭の値を返して <code>do_parse</code>、
<code>yyparse</code> を抜けます。

</dl>


<% footer 1999 %>
. file debug.html ----------------------------------------------------------
<% header 'Debug' %>

<h1>デバッグ情報</h1>

<hr>
<p>
ここでは、Racc を使っていくうえで遭遇しそうなバグについて書きます。
ただ、徐々に減ってはいますが、現時点ではまだまだ racc 自身のバグの可能性も高いです。
もし「これはバグに違いない！」というエラーに遭遇したらメールをください。
そのときは、規則ファイルなどもつけてくださるようお願いします。

<p>
また、racc コマンドに -v オプションをつけてコンパイルすると、内部情報が
"ファイル名.output" に出力されます。このファイルの情報はデバッグには
必須ですから、デバッグ中は常に -vg をつけてコンパイルすることをおすすめします。


<h2>インストールできないんだけど。</h2>
<p>
どうしたらいいんでしょうねえ。

<h2>規則ファイルがパースエラーになるよう。</h2>
<p>
エラーメッセージに出てる行に文法の間違いがあります。
どこが間違ってるかは じっと見て考えましょう。

<h2>衝突</h2>
<p>
一番ありがちな問題は、衝突でしょうか。
衝突があると、racc がコンパイル後に「衝突がある」とメッセージを
出すのですぐわかります。.output ファイルにはさらに詳しい情報が出力されます。
それをどうやって解決するか、とかそういうことに関しては、それなりの本を読んでください。
とてもここに書けるような単純な話ではありません。例えば O'Reilly の「lex & yacc」。

<h2>next_token に関して</h2>
<p>
いまだ自分でも忘れることが多いのが、「スキャンが終了したら[false,なにか]を送る」
ということです。0.10.2 からは一回送ったらもうそれ以上は next_token を呼びません。

<h2>デバッグ出力</h2>
<p>
racc に -g オプションをつけてコンパイルすると、デバッグ用のコードが付加されます。
ここで、パーサクラスのインスタンス変数 @yydebug を true にしておいてから
do_parse を呼ぶと、デバッグ用メッセージを出力します。パーサがシフト/還元していく
様子が直接見えますので、完全に現在の状態を把握できます。
どこで止まっているのかがわかればあとは直すだけ。

<hr>
<h2>yaccとの文法の違い</h2>


<h3>定義部</h3>
<p>
yacc では % がいっぱいでてきますが、racc では % は出てきません。
それから、C では変数に型があるためにそれを指定する文法がたくさんありますが、
Ruby は型無しですからそっち関係のものはなくなっています。
<p>
yacc では終端記号(トークン)を事前に指定しますが、
Racc では左辺にこないものを自動的に終端記号とみなします。
ということはつまり、非終端記号 nonterm を noterm と書きまちがったがために、
それが終端記号とみなされて、妙なことになる可能性があるということです。
これを防止するためには、.output ファイルを出力させて、変なものが終端記号になって
いないか(もちろんその逆も)チェックするとよいでしょう。
<p>
バージョン 0.10 からは全体の構造が class ... rule ... end のようになりました。


<h3>規則部</h3>
<p>
規則部分は yacc とほぼ同じです。
<p>
%prec は = をつかいます。
<p>
yacc ではコメントは /* ... */ だけですが racc では #...(行末) もあります。


<h3>ユーザーコード部</h3>
<p>
yacc ではユーザーコードを分類する必要はありませんが、racc ではパーサがクラスなので、
配置する場所によってユーザーコードを分類しています。ユーザーコードの指定方法も
0.9 で ---- を使うように大きく変わったので気をつけてください。

<% footer 1999 %>
. file changes.html ----------------------------------------------------------
<% header 'Change Log' %>

<h1>変更履歴</h1>

<hr>
<h2>1.3.9 (2001-04-07)</h2>
<p>
<ul>
<li>Ruby 1.4 に(再び)対応した
</ul>

<h2>1.3.8 (2001-03-17)</h2>
<p>
<ul>
<li>パースエラーの時に記号名も出力するようにした
<li>Racc::Parser#token_to_s
<li>ジェネレータにバグ。以下の文法の衝突を解決できなかった
<blockquote><pre>
targ      : operation nullhead
	  | variable
nullhead  : null B
null      :
operation : A
variable  : A
</pre></blockquote>
</ul>

<h2>1.3.7 (2001-02-04)</h2>
<p>
<ul>
<li>実験的に、入力トークンの終端は nil でもよいことにした。
    バグの発見が遅れるようであればやっぱりやめる。
<li>サンプルを増やした
</ul>

<h2>1.3.6 (2001-01-22)</h2>
<p>
<ul>
<li>cparse がスタティックリンクされても動くようにした
</ul>

<h2>1.3.5 (2001-01-18)</h2>
<p>
<ul>
<li>% 文字列のスキャンがバグってた
<li>新しい命令 expect
</ul>

<h2>1.3.4 (2001-01-11)</h2>
<p>
<ul>
<li>cparse: シンボルのタイプチェックを入れた
<li>cparse: depend を消した
<li>cparse: rb_iterate 中の GC で落ちるバグを修正
</ul>

<h2>1.3.3 (2000-12-25)</h2>
<p>
<ul>
<li>ジェネレータに致命的なバグ。1.3.1 から混入 (format.rb)
<li>racc --runtime-version
</ul>

<h2>1.3.2 (2000-12-21)</h2>
<p>
<ul>
<li>-E が失敗するのを直した
<li>再度 strscan を同梱 (y2racc/racc2y に必要)
</ul>

<h2>1.3.1 (2000-12-17)</h2>
<p>
<ul>
<li>正規表現の繰り返し指定の上限を動的に決定する (RE_DUP_MAX)
<li>パースルーチンが常に Ruby 版になっていた (消し忘れ。)
</ul>

<h2>1.3.0 (2000-11-30)</h2>
<p>
<ul>
<li>スキャナから yield でトークンを渡せるようになった
</ul>

<hr>
<h2>1.2.6 (2000-11-28)</h2>
<p>
<ul>
<li>class M::C を許した
</ul>

<h2>1.2.5 (2000-11-20)</h2>
<p>
<ul>
<li>オプションに大変動。非互換オプションは -h -f -p -i -n -c -A
<li>ロングオプションをサポート
<li>y2racc, racc2y はデフォルトでアクションを残すようにした
</ul>

<h2>1.2.4 (2000-09-13)</h2>
<p>
<ul>
<li>インストーラとドキュメントを更新
</ul>

<h2>1.2.3 (2000-08-14)</h2>
<p>
<ul>
<li>使われない規則と非終端記号を出力 (強力版)
<li>S/R conflict の時 nonassoc で解決するならばエラー
</ul>

<h2>1.2.2 (2000-08-12)</h2>
<p>
<ul>
<li>内部の変更
</ul>

<h2>1.2.1 (2000-08-05)</h2>
<p>
<ul>
<li>yacc との変換コマンド racc2y・y2racc を添付
</ul>

<h2>1.2.0 (2000-08-02)</h2>
<p>
<ul>
<li>先読みアルゴリズムを bison のものに変更
</ul>

<hr>
<h2>1.1.6 (2000-07-25)</h2>
<p>
<ul>
<li>新たなキーワード options とその引数 no_result_var
</ul>

<h2>1.1.5 (2000-07-21)</h2>
<p>
<ul>
<li>[重要] token を convert に変更
<li>「新たな」キーワード token (終端記号の宣言)
</ul>

<h2>1.1.4 (2000-07-13)</h2>
<p>
<ul>
<li>インストーラをアップデート。
    cparse を選択インストールできるようにした
<li>サンプルがバグってた
</ul>

<h2>1.1.3 (2000-06-30)</h2>
<p>
<ul>
<li>空アクションの呼び出しを省略しないようにするオプション -a
</ul>

<h2>1.1.2 (2000-06-29)</h2>
<p>
<ul>
<li>スキャナで strscan を使わないようにした
<li>ScanError -&gt; Racc::ScanError, ParseError -&gt; Racc::ParseError
<li>エラーメッセージを強化
</ul>

<h2>1.1.1 (2000-06-15)</h2>
<p>
<ul>
<li>requireミス (thanks Toshさん)
<li>-v をつけるとconflictが報告されなくなっていた
</ul>

<h2>1.1.0 (2000-06-12)</h2>
<p>
<ul>
<li>新しい 状態遷移表生成アルゴリズム
</ul>

<hr>
<h2>1.0.4 (2000-06-04)</h2>
<p>
<ul>
<li>S/R conflict がおきると .output 出力で落ちるバグ修正 (Tosh さんの報告)
<li>使われない非終端記号・規則を表示
</ul>

<h2>1.0.3 (2000-06-03)</h2>
<p>
<ul>
<li>filter -&gt; collect!
</ul>

<h2>1.0.2 (2000-05-16)</h2>
<p>
<ul>
<li>インストーラをアップデート
</ul>

<h2>1.0.1 (2000-05-12)</h2>
<p>
<ul>
<li>state.rb:  先読みルーチンをちょっとだけ高速化 && 追加デバッグ
<li>コードを整理した。著作権表示全体を全部のファイルにつけた。
<li>amstd アップデート (1.7.0)
</ul>

<h2>1.0.0 (2000-05-06)</h2>
<p>
<ul>
<li>バージョン 1.0
</ul>

<hr>
<h2>0.14.6 (2000-05-05)</h2>
<p>
<ul>
<li>デバッグ出力を詳細にした
</ul>

<h2>0.14.5 (2000-05-01)</h2>
<p>
<ul>
<li>インストーラを ruby 1.4.4 系の新しいパスに対応させた
    (thanks rubykitch さん、Tosh さん)
</ul>

<h2>0.14.4 (2000-04-09)</h2>
<p>
<ul>
<li>パーサの定数を削減(Racc_arg にまとめた)
<li>state 生成を微妙に高速化(コアを文字列に変換)
</ul>

<h2>0.14.3 (2000-04-04)</h2>
<p>
<ul>
<li>cparse の SYM2ID と ID2SYM のチェックを分離 (thanks 小松さん)
</ul>

<h2>0.14.2 (2000-04-03)</h2>
<p>
<ul>
<li>一行目の class がパースエラーになっていた (thanks 和田さん)
<li>新しいフラグ racc -V
</ul>

<h2>0.14.1 (2000-03-31)</h2>
<p>
<ul>
<li>インストーラで Ruby のパスを指定したときには
    system に与えるRubyのパスも変えるようにした (thanks Toshさん)
</ul>

<h2>0.14.0 (2000-03-21)</h2>
<p>
<ul>
<li>高速テーブルを実装
<li>一時的にファイル名/行番号の変換をやめた(Rubyのバグのため。)
</ul>

<hr>
<h2>0.13.1 (2000-03-21)</h2>
<p>
<ul>
<li>--version --copyright などがうまく働いてなかった (thanks ふなばさん)
</ul>

<h2>0.13.0 (2000-03-20)</h2>
<p>
<ul>
<li>yyerror/yyerrok/yyaccept を実装
</ul>

<hr>
<h2>0.12.2 (2000-03-19)</h2>
<p>
<ul>
<li>-E フラグがバグってた (thanks ふなばさん)
</ul>

<h2>0.12.1 (2000-03-16)</h2>
<p>
<ul>
<li>デフォルトアクションの決め方をちょっと修正(元に戻しただけ)
</ul>

<h2>0.12.0 (2000-03-15)</h2>
<p>
<ul>
<li>別のバグどころではなかった。先読みルーチンが LALR になっていない。
    四日がかりでようやく修正した。
<li>完全な LALR を実装したら遅くなったので SLR も併用するようにした。効果絶大。
</ul>

<hr>
<h2>0.11.3 (2000-03-09)</h2>
<p>
<ul>
<li>状態遷移表生成のバグの修正がまだ甘かった。さらに別のバグもあるようだ。
</ul>

<h2>0.11.2 (2000-03-09)</h2>
<p>
<ul>
<li>状態遷移表生成部に(最後(になってほしい)の)バグ。
    先読みコードが再帰した場合にトークンが少なくなってしまっていた
<li>cparse が Symbol に対応できてなかった
</ul>

<h2>0.11.1 (2000-03-08)</h2>
<p>
<ul>
<li>ruby 1.5 の Symbol に対応
<li>strscan を最新に
</ul>

<h2>0.11.0 (2000-02-19)</h2>
<p>
<ul>
<li>例外のとき、元のファイルの行番号が出るようにした
</ul>

<hr>
<h2>0.10.9 (2000-01-19)</h2>
<p>
<ul>
<li>セットアップ方法など細かな変更
</ul>

<h2>0.10.8 (2000-01-03)</h2>
<p>
<ul>
<li>忘れてしまったけどたしかインストーラ関係の修正
<li>(1/17 re-packed) ドキュメントの追加と修正
</ul>

<h2>0.10.7 (2000-01-03)</h2>
<p>
Thanks 新井さん
<ul>
<li>setup.rb compile.rb amstd/inst などのバグ修正
</ul>

<h2>0.10.6 (1999-12-24)</h2>
<p>
<ul>
<li>racc -e ruby でデフォルトパスを使用
<li>空のアクションの呼びだしは省略するようにした
</ul>

<h2>0.10.5 (1999-12-21)</h2>
<p>
thanks Toshさん
<ul>
<li>埋めこみアクションの実装がすさまじくバグってた
<li>setup.rb が inst.rb の変化に追従してなかった
<li>calc.y calc2.y を 0.10 用に修正
</ul>

<h2>0.10.4 (1999-12-19)</h2>
<p>
<ul>
<li>エラー回復モードを実装
<li>racc -E で単体で動作するパーザを生成
<li>Racc は class から module になった
</ul>

<h2>0.10.3 (1999-12-01)</h2>
<p>
<ul>
<li>埋めこみアクションをサポート
<li>.output の出力内容にバグがあったのを修正
</ul>

<h2>0.10.2 (1999-11-27)</h2>
<p>
<ul>
<li>ドキュメントの訂正と更新
<li>libracc.rb を分割
</ul>

<h2>0.10.1 (1999-11-19)</h2>
<p>
<ul>
<li>C でランタイムを書きなおした
<li>next_token が false を返したらもう読みこまない
<li>アクションがトークンによらず決まるときは next_token を呼ばない
<li>$end 廃止
<li>LALRactionTable
</ul>

<h2>0.10.0 (1999-11-06)</h2>
<p>
<ul>
<li>next_* を next_token に一本化、peep_token 廃止
<li>@__debug__ -&lt; @yydebug など変数名を大幅変更
<li>文法ファイルの構造が class...rule...end に変わった
<li>コアのコードを一新、高速化
<li>strscan を併合
<li>ライブラリを racc/ ディレクトリに移動
</ul>

<hr>
<h2>0.9.5 (1999-10-03)</h2>
<p>
thanks > Toshさん
<ul>
<li>0.9.4 の変更がすごくバグってた
<li>$end が通らなかったのを修正
<li>__show_stack__ の引数が違ってた
</ul>

<h2>0.9.4 (1999-09-??)</h2>
<p>
<ul>
<li>Parser::Reporter をなくしてメソッドに戻した
<li>d.format.rb を再編成
</ul>

<h2>0.9.3 (1999-09-03)</h2>
<p>
<ul>
<li>racc.rb -> racc
</ul>

<h2>0.9.2 (1999-06-26)</h2>
<p>
<ul>
<li>strscan使用
</ul>

<h2>0.9.1 (1999-06-08)</h2>
<p>
<ul>
<li>アクション中の正規表現に対応 ( /= にも注意だ)
<li>アクション中の # コメントに対応
</ul>

<h2>0.9.0 (1999-06-03)</h2>
<p>
<ul>
<li>アクションを { } 形式にした
<li>ユーザーコードを '----' を使う形式にした
</ul>


<hr>

<h2>0.8.11 (?)</h2>
<p>
<ul>
<li>-g 出力をわかりやすくした
</ul>

<h2>0.8.10 (?)</h2>
<p>
<ul>
<li>アクションからreturnできるようにした
</ul>

<h2>0.8.9 (1999-03-21)</h2>
<p>
<ul>
<li>-g + @__debug__をつかったデバッグメッセージ操作
<li>エラー発生時のバグを修正
<li>TOKEN_TO_S_TABLEを付加するようにした
</ul>

<h2>0.8.8 (1999-03-20)</h2>
<p>
<ul>
<li>100倍程度の高速化
<li>defaultトークンを加えた
<li>デバッグ用ソースを出力するオプション-gをくわえた
<li>user_initializeを廃止し、普通にinitializeを使えるようにした
<li>parse_initialize/finalize,parseメソッドを廃止
<li>next_token,next_value,peep_tokenのデフォルトを廃止
<li>%precと同等の機能を加えた
</ul>

<h2>0.8.7 (1999-03-01)</h2>
<p>
<ul>
<li>内部構造が大幅に変化
<li>マニュアルがHTMLになった
</ul>

<h2>0.8.0 (1999-01-16)</h2>
<p>
なぜいきなり 0.8 ？？？
<ul>
<li>文法がブロック型に変化
</ul>

<h2>0.5.0 (1999-01-07)</h2>
<p>
<ul>
<li>演算子優先順位が実装されたようだ
<li>スタート規則が実装されたようだ
<li>トークン値の置換が実装されたようだ(後に致命的なバグ発見)
</ul>

<h2>0.1.0 (1999-01-01)</h2>
<p>
とにかく動くようになった

<% footer 1999 %>
