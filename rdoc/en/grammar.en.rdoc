= Racc Grammar File Reference

== Global Structure

== Class Block and User Code Block

There are two blocks on toplevel.
One is the 'class' block and the other is the 'user' block.
You MUST write the 'user' block after the 'class' block.
The 'class' block can also be called the 'rule' block or the 'class definition'
block.

== Comment

You can insert comment about all places.
There are two possible comment styles,
Ruby style (#.....) and C style (/*......*/) .

== Class Block

The class block is formed like this:
--
class CLASS_NAME
  [precedance table]
  [token declearations]
  [expected number of S/R conflict]
  [options]
  [semantic value convertion]
  [start rule]
rule
  GRAMMARS
--
CLASS_NAME is the name of the parser class to be defined.
This is used as the name of the parser class in the generated file
which is written in Ruby.

If CLASS_NAME includes '::', Racc outputs module clause.
For example, when CLASS_NAME is "M::C",
the parser class is defined as follows in the generated file.
--
module M
  class C
    :
    :
  end
end
--

== Grammar Block

The grammar block is where you write grammars understood by the generated parser.
It is written between the reserved words 'rule' and 'end' and its syntax is as follows:
--
(token): (token) (token) (token).... (action)

(token): (token) (token) (token).... (action)
       | (token) (token) (token).... (action)
       | (token) (token) (token).... (action)
--

(action) is executed when its (token)s are found.
(action) is basically a ruby code block which is surrounded by braces:
--
{ print val[0]
  puts val[1] }
--
However, you cannot use some of Ruby syntax inside action,
for instance, you cannot use '%' string, here document, '%r' regexp.

The return value of an action is the left-hand side (lhs) value of the rule.
This is $$ in yacc.
The way to return the value depends on the option you set.
By default, the 'result' local variable (this is val[0] by default) represents
the left-hand side value, thus the value stored in the 'result' variable
by the end of the action would be the left-hand side value.
Otherwise, you can explicitly 'return' the return value.
Alternatively, when you set no_result_var option via options,
the lhs value is the value of the last statement in the action block (as the
same as Ruby methods).

In whichever way, you can omit actions.
When it is omitted, the left-hand side value is always val[0].

Here is an example of whole grammar block.
--
rule
  goal: definition ruls source { result = val }

  definition: /* none */   { result = [] }
    | definition startdesig  { result[0] = val[1] }
    | definition
             precrule   # this line continue from upper line
      {
        result[1] = val[1]
      }

  startdesig: START TOKEN
--

You can use following special local variables inside actions.
The symbols surrounded by parentheses are how they are represented when using
yacc.

  * result ($$)

The value of left-hand side (lhs). This is val[0] by default.

  * val ($1,$2,$3...)

An array of the right-hand side (rhs) values.
This is generated every time, so you can freely modify or discard it.

  * _values (...$-2,$-1,$0)

A stack of values used by the Racc core.
DO NOT MODIFY this stack unless you know what you are doing.

There is also a special form of action which is called embedded action.
It is an action which can be written wherever you like in the middle of the
token sequence.
Here is an example of the embedded action.
---
target: A B { puts 'test test' } C D { normal action }
---

When a rule is written like this,
the action written between B and C is executed at the moment just after both A
and B are found.
An embedded action itself has its value. That is, in the following example,
--
target: A { result = 1 } B { p val[1] }
--
when the last action block { p val[1] }  is executed,
it shows 1 that is the value of the embedded action and not the value of B.

In its effect, writing an embedded action is the same as adding a nonterminal
symbol whose rule is empty. The above example and the following code mean
completely the same.
--
target  : A nonterm B { p val[1] }
nonterm : /* empty rule */ { result = 1 }
--


== Operator Precedence

When there's a shift/reduce conflict on a token,
sometimes the conflict can be eliminated by defining operator precedences.
The famous examples of such case are arithmetic operators and if-else syntax.

It does not mean setting operator precedences is necessary to resolve conflicts
because usually it can also be solved by changing the way to construct rules.
However, using operator precedence results in the simpler grammar in most cases.

When shift/reduce conflicts occur, Racc first investigate whether the precedence
is set on the rule. The precedence of a rule is equal to the precedence of the
last terminal symbol of the rule.
For instance,
--
target: TERM_A nonterm_a TERM_B nonterm_b
--
the precedence of this rule is the precedence of TERM_B.
If not any precedence is set on TERM_B,
Racc would consider that it could not solve the conflict by precedence
and report "Shift/Reduce conflict".

This is how to designate the operator precedences:
--
prechigh
  nonassoc '++'
  left     '*' '/'
  left     '+' '-'
  right    '='
preclow
--

The token written in the line closer to prechigh has the higher precedence.
You can also write this upside-down, that is, writing preclow above and prechigh
at the bottom.

Left, right and nonassoc represent associativity.
When a confliction occurs between the operators whose precedences are the same
their associativities are used to decide whether shift or reduce.

For instance, think of the following case:
--
a - b - c
--

When - is left-associative, this is interpreted as follows:
--
(a - b) - c
--
Arithmetic operators are usually left-associative.

On the other hand,
if - is right-associative, it is interpreted as follows:
--
a - (b - c)
--

When an operator is not allowed to be written in succession like this in the
first place, it is nonassoc.
++ in C language and unary minus are nonassoc.

The left, right, nonassoc are %left, %right and %nonassoc in yacc.


By the way, as described, usually the precedence of the rule to be reduced is
the precedence of the last token. (the term 'token' used here means the terminal
symbol.) But sometimes we want to change the precedence of a particular token
only inside a particular rule. For example, the precedence of unary minus must
be higher than the precedence of minus for subtraction.

In such case, you can use %prec in yacc and you can do the same thing by using
'=' + (symbol) with racc.
--
prechigh
  nonassoc UMINUS
  left '*' '/'
  left '+' '-'
preclow

rule
  exp: exp '*' exp
     | exp '-' exp
     | '-' exp       =UMINUS   # changing the precedence of - only here
         :
         :
--

In the above example, the precedence of the '-' exp rule is equal to the
precedence of UMINUS and higher than the precedence of '*', as we intended.


== Declaring Tokens

By explicitly declaring tokens,
you can avoid many meaningless bugs, especially typos.
If a declared token does not exist or an existing token is not declared,
Racc outputs warnings.  Declaration syntax is:
--
token TOKEN_NAME AND_IS_THIS
      ALSO_THIS_IS AGAIN_AND_AGAIN THIS_IS_LAST
--

This feature is similar to %token in yacc but slightly different.
With racc, this is not required and even if the tokens are declared, it does not
cause errors but only warnings.

Please notice that you can write the declaration spanning over multiple lines.

Racc do have the reserved words but they are considered as the reserved words
only when they are written at the beginning of the line. Therefore, for instance,
prechigh can also be used as a symbol. However, for an abyssal reason, no matter
what we do, we cannot use 'end' as a symbol.


== Options

You can write some of the options for racc command in your racc file as their
default values.
--
options OPTION OPTION ...
--
Currently, the options you can write here are:

  * omit_action_call
  * no_omit_action_call

To omit or not to omit empty action call or not.

  * result_var
  * no_result_var

To use or not to use local variable "result"


== expect

Racc has bison's "expect" directive.

A practical parser usually contains non-harmful shift/reduce conflicts.
It is ok for the person who wrote the grammar because he or she knows it,
however, if racc reports "conflicts" after a user processed the grammar file,
he or she might be anxious.
In that case, you can declare the expected number of the conflicts to suppress
the warning message.

--
# Example

class MyParser
rule
  expect 3
    :
    :
--

When you declared the expected number of shift/reduce conflicts as 3 like the
above code, the number of conflicts should exactly be 3.
If it was not 3 (even it was zero), racc would print the warning message.

Besides,
you could not suppress the warning message for reduce/reduce conflict.


== Converting Token Symbol

Token symbols are, by default:

  * naked token string in racc file (TOK, XFILE, this_is_token, ...)
    --&gt; symbol (:TOK, :XFILE, :this_is_token, ...)
  * quoted string (':', '.', '(', ...)
    --&gt; same string (':', '.', '(', ...)

This can be inconvenient when you already have a scanner returning values in a
different form. In that case, you can change this using "convert" block.

Here is an example:
--
convert
  PLUS 'PlusClass'      # We use PlusClass for symbol of `PLUS'
  MIN  'MinusClass'     # We use MinusClass for symbol of `MIN'
end
--

By default, the value of the token symbol PLUS is :PLUS.
But when there's the above definition, it becomes PlusClass.


We can use all ruby values as token symbol values
except 'false' and 'nil'.

If you want to use String as token symbol, special care is required.
For example:
--
convert
  class '"cls"'            # in code, "cls"
  PLUS '"plus\n"'          # in code, "plus\n"
  MIN  "\"minus#{val}\""   # in code, \"minus#{val}\"
end
--

== Start Rule

In order to create a parser, you need to tell racc which rule is the first rule.
The start rule is a way to write it explicitly.

--
start real_target
--
This is usually omitted and in that case,
the start rule is the first rule in the file.
This statement will not be used forever, I think.

This is '%start' in yacc.

== User Code Block

"User Code Block" is a Ruby source code which is copied to the output file.
There are three user code blocks, "header" "inner" and "footer".

The code written in "header" block is copied to just before the parser class
definition. "inner" is for inside (and the beginning of) the class definition,
and "footer" is after the definition.

Format of user code is like this:
--
---- header
  ruby statement
  ruby statement
  ruby statement

---- inner
  ruby statement
     :
     :
--
If four '-' exist on line head,
racc treats it as the beginning of a user code block.
A name of user code must be one word.
