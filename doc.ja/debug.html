<h1>デバッグ情報</h1>

<hr>
<p>
ここでは、Racc を使っていくうえで遭遇しそうな問題について書きます。
Racc を使っていてなにか問題が起きたらまず一通りながめてみてください。
</p>
<p>
それでも解決せず、なにも有意義なメッセージが出てこない場合は
Racc 自身のバグである可能性もありえます。もし「これはバグに違いない！」
という状況になったら作者にメールをください。そのときは必ず OS や Ruby の
バージョンを書き、文法ファイルも関係ありそうならそれも添付してください。
</p>


<h2>インストールできないんだけど。</h2>
<p>
どういうエラーが出ていますか？ たぶん簡単な英語でなにかメッセージが
出ていると思いますから、冷静に読んでみましょう。setup.rb でエラーが
起きた場合は ruby -d setup.rb で起動すると生のエラーメッセージが
取れるので見てみてください。
</p>


<h2>規則ファイルがパースエラーになるよう。</h2>
<p>
エラーメッセージに行番号を示す数字が出ているはずです。その行をジッと
見て考えましょう。ブロックを閉じる行でエラーになる場合は、どこかで
開き括弧(など)だけを増やしてしまっている可能性が高いです。
</p>


<h2>パーサは問題なく生成できたけど予想どおりに動かない</h2>
<p>
racc に -g オプションをつけてパーサを出力すると、デバッグ用のコードが
付加されます。ここで、パーサクラスのインスタンス変数 @yydebug を true に
しておいてから do_parse/yyparse を呼ぶと、デバッグ用メッセージが出力
されます。パーサが動作する様子が直接見えますので、完全に現在の状態を
把握できます。これを見てどこがおかしいのかわかったらあとは直すだけ。
</p>


<h2>next_token に関して</h2>
<p>
いまだ自分でも忘れることが多いのが「送るトークンが尽きたら [false,なにか] を送る」
ということです。0.10.2 からは一回送ったらもうそれ以上は next_token を呼びません。
</p>
<p>
最近、nil でもよいことになった。
</p>


<h2>なんたら conflict って言われたんだけど</h2>
<p>
一番ありがちで一番面倒な問題は衝突 (conflict) でしょう。文法中に衝突が
あると、racc がコンパイル後に「5 shift/reduce conflict」のようなメッセージを
出します。-v をつけると出力される .output ファイルからはさらに詳しい情報が
得られます。それをどう使うか、とかそういうことに関しては、それなりの本を
読んでください。とてもここに書けるような単純な話ではありません。
当然ながら『Ruby を 256 倍使うための本 無道編』(青木峰郎著)がお勧めです。
</p>


<hr>
<h2>yacc との文法の違い</h2>

<h3>定義部</h3>
<p>
yacc では % がいっぱいでてきますが、racc では % は出てきません。
それから、C では変数に型があるためにそれを指定する文法がたくさんありますが、
Ruby は型無しですからそっち関係のものはなくなっています。
<p>
yacc では終端記号(トークン)を事前に指定しますが、
Racc では左辺にこないものを自動的に終端記号とみなします。
ということはつまり、非終端記号 nonterm を noterm と書きまちがったがために、
それが終端記号とみなされて、妙なことになる可能性があるということです。
これを防止するためには、.output ファイルを出力させて、変なものが終端記号になって
いないか(もちろんその逆も)チェックするとよいでしょう。
<p>
バージョン 0.10 からは全体の構造が class ... rule ... end のようになりました。

<h3>規則部</h3>
<p>
規則部分は yacc とほぼ同じです。
<p>
%prec は = をつかいます。
<p>
yacc ではコメントは /* ... */ だけですが racc では #...(行末) もあります。

<h3>ユーザーコード部</h3>
<p>
yacc ではユーザーコードを分類する必要はありませんが、racc ではパーサがクラスなので、
配置する場所によってユーザーコードを分類しています。ユーザーコードの指定方法も
0.9 で ---- を使うように大きく変わったので気をつけてください。
