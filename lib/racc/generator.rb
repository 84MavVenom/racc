#
# $Id$
#
# Copyright (c) 1999-2006 Minero Aoki
#
# This program is free software.
# You can distribute/modify this program under the terms of
# the GNU LGPL, Lesser General Public License version 2.1.
# For details of the GNU LGPL, see the file "COPYING".
#

require 'racc/parser-text'
require 'rbconfig'

module Racc

  class CodeGenerator

    def self.bool_attr(name)
      module_eval(<<-End)
        def #{name}?
          @#{name}
        end

        def #{name}=(b)
          @#{name} = b
        end
      End
    end

    bool_attr :debug_parser
    bool_attr :omit_action_call
    bool_attr :result_var
    bool_attr :convert_line

    attr_accessor :filename
    attr_accessor :lineno_base

    bool_attr :convert_line_all
    attr_accessor :classname
    attr_accessor :superclass
    bool_attr :make_executable
    attr_accessor :interpreter
    bool_attr :embed_runtime
    attr_accessor :runtime

    def initialize(states)
      @states = states
      @grammar = states.grammar

      # Options derived from parser
      self.omit_action_call = true
      self.result_var = true
      self.classname = nil
      self.superclass = nil

      # Options derived from command line
      self.filename = nil
      self.lineno_base = 0

      # Options derived from command line options
      self.debug_parser = false
      self.convert_line = true
      self.convert_line_all = false
      self.make_executable = false
      self.interpreter = nil
      self.embed_runtime = false
      self.runtime = nil
    end

    def generate_parser_file(filename)
      @tabfn = filename
      @is_top = false
      @uniq = {}
      open(@tabfn) {
        shebang @interpreter if make_executable?
        notice
        require embed_runtime?, (@runtime || 'racc/parser')
        header
        parser_class(@classname, @superclass) {
          inner
          parser_table @f
        }
        footer
      }
      File.chmod 0755, outfile if make_executable?
    end

    private

    def open(path)
      init_user_code
      File.open(path, 'w') {|f|
        @f = f
        yield self
      }
    end

    c = ::Config::CONFIG
    RUBY_PATH = "#{c['bindir']}/#{c['ruby_install_name']}#{c['EXEEXT']}"

    def shebang(path)
      @f.print "#!#{path == 'ruby' ? RUBY_PATH : path}\n"
    end

    def notice
      @f.puts %q[#]
      @f.puts %q[# DO NOT MODIFY!!!!]
      @f.puts %Q[# This file is automatically generated by Racc #{Racc::Version}]
      @f.puts %Q[# from racc grammer file "#{@filename}".]
      @f.puts %q[#]
    end

    def require(embed_p, parser_rb)
      if embed_p
        @f.puts '#'
        @f.puts "# #{@tabfn}: generated by racc (runtime embedded)"
        @f.puts '#'
        is_top {
          @f.puts %<###### racc/parser.rb begin>
          @f.puts %<unless $".index 'racc/parser.rb'>
          @f.puts %<$".push 'racc/parser.rb'>
          add ::Racc::PARSER_TEXT, 'racc/parser.rb', 1
          @f.puts %<end>
          @f.puts %<###### racc/parser.rb end>
        }
        @f.puts
      else
        @f.puts
        @f.puts  "require '#{parser_rb}'"
        @f.puts
      end
    end

    def parser_class(classname, superclass)
      @f.puts
      mods = classname.split('::')
      real = mods.pop
      mods.each_with_index do |m,i|
        @f.puts  "#{'  ' * i}module #{m}"
        @f.puts
      end
      @f.puts "#{'  ' * mods.size}class #{real} < #{superclass}"
      yield
      @f.puts "#{'  ' * mods.size}end   \# class #{real}"
      mods.reverse.each_with_index do |m,i|
        @f.puts
        @f.puts  "#{'  ' * (mods.size - i - 1)}end   \# module #{m}"
      end
    end

    HEADER_LABELS = %w( header prepare )
    INNER_LABELS  = %w( inner )
    FOOTER_LABELS = %w( footer driver )

    def header
      is_top {
        add_part convert_line_all?, HEADER_LABELS
      }
    end

    def inner
      add_part convert_line?, INNER_LABELS
    end

    def footer
      is_top {
        add_part convert_line_all?, FOOTER_LABELS
      }
    end

    #
    # init
    #

    def init_user_code
      @usercode = Racc::GrammarFileParser.get_usercode(@filename)
      check_duplicated_user_code
    end

    def check_duplicated_user_code
      [HEADER_LABELS, INNER_LABELS, FOOTER_LABELS].each do |names|
        codes = names.select {|n| @usercode[n] }
        if codes.length > 1
          raise Racc::CompileError, "#{codes.join(' and ')} are exclusive"
        end
      end
    end

    #
    # part
    #

    def add_part(convline, names)
      str, lineno, fnames = getent(names)
      line_convert(convline) {
        add str, @filename, lineno if str and not str.strip.empty?
      }
      fnames.each do |n|
        add_file n
      end if fnames
    end

    def getent(names)
      names.map {|n| @usercode[n] }.compact[0]
    end

    def line_convert(b)
      save, @convert_line = @convert_line, b
      yield
      @convert_line = save
    end

    #
    # low level code
    #

    def add_file(fname)
      File.open(fname) {|f|
        add f.read, fname, 1
      }
    end

    def add(str, fn, lineno)
      @f.puts
      if @convert_line
        surrounding_by_eval(fn, str, lineno) {
          @f.puts str
        }
      else
        @f.puts str
      end
    end

    def surrounding_by_eval(nm, str, lineno)
      sep = makesep(nm, str)
      @f.print 'self.class.' if toplevel?
      @f.puts "module_eval <<'#{sep}', '#{nm}', #{lineno}"
      yield
      @f.puts sep
    end

    def is_top
      @is_top = true
      yield
      @is_top = false
    end

    def toplevel?
      @is_top
    end

    def makesep(nm, str)
      sep = uniqlabel(nm)
      sep *= 2 while str.index(sep)
      sep
    end

    def uniqlabel(nm)
      ret = "..end #{nm} modeval..id"
      srand
      5.times do
        ret << sprintf('%02x', rand(255))
      end
      ret << sprintf('%02x', rand(255)) while @uniq[ret]
      @uniq[ret] = true
      ret
    end

    #
    # Parser Table
    #

    public

    def parser_table(f)
      f.print "\n##### Racc #{Racc::Version} generates ###\n\n"
      output_reduce_table f
      output_action_table f
      output_goto_table f
      output_token_table f
      output_other f
      f.puts '##### Racc system variables end #####'
      output_actions f
    end

    private

    def output_reduce_table(out)
      out << "racc_reduce_table = [\n"
      out << " 0, 0, :racc_error,"
      sep = "\n"
      sep_rest = ",\n"
      @grammar.each_with_index do |rl, i|
        next if i == 0
        out.print sep; sep = sep_rest
        out.printf ' %d, %d, :_reduce_%s',
            rl.size, rl.target.ident,
            (omit_action_call? and not rl.action) ? 'none' : i.to_s
      end
      out << " ]\n\n"
      out << "racc_reduce_n = #{@states.reduce_n}\n\n"
      out << "racc_shift_n = #{@states.shift_n}\n\n"
    end

    def output_action_table(out)
      tbl  = []   # yytable
      chk  = []   # yycheck
      defa = []   # yydefact
      ptr  = []   # yypact
      state = tmp = min = max = i = nil
      e1 = []
      e2 = []

      @states.each do |state|
        defa.push act2actid(state.defact)

        if state.action.empty?
          ptr.push nil
          next
        end
        tmp = []
        state.action.each do |tok, act|
          tmp[tok.ident] = act2actid(act)
        end
        addent e1, e2, tmp, state.ident, ptr
      end
      set_table e1, e2, tbl, chk, ptr

      output_table out, tbl, 'racc_action_table'
      output_table out, chk, 'racc_action_check'
      output_table out, ptr, 'racc_action_pointer'
      output_table out, defa, 'racc_action_default'
    end

    def output_goto_table(out)
      tbl  = []   # yytable (2)
      chk  = []   # yycheck (2)
      ptr  = []   # yypgoto
      defg = []   # yydefgoto
      state = dflt = tmp = freq = min = max = i = nil
      e1 = []
      e2 = []

      @grammar.each_nonterminal do |tok|
        tmp = []

        #
        # decide default
        #
        freq = Array.new(@states.size, 0)
        @states.each do |state|
          st = state.goto_table[tok]
          if st
            st = st.ident
            freq[st] += 1
          end
          tmp[state.ident] = st
        end
        max = freq.max
        if max > 1
          dflt = freq.index( max )
          tmp.map! {|i| dflt == i ? nil : i }
        else
          dflt = nil
        end

        # default
        defg.push dflt

        #
        # delete default value
        #
        tmp.pop until tmp[-1] or tmp.empty?
        if tmp.compact.empty?
          # only default
          ptr.push nil
          next
        end

        addent e1, e2, tmp, (tok.ident - @grammar.nonterminal_base), ptr
      end
      set_table e1, e2, tbl, chk, ptr

      output_table out, tbl, 'racc_goto_table'
      output_table out, chk, 'racc_goto_check'
      output_table out, ptr, 'racc_goto_pointer'
      output_table out, defg, 'racc_goto_default'
    end

    def addent(all, dummy, arr, chkval, ptr)
      max = arr.size
      min = nil
      item = idx = nil
      arr.each_with_index do |item,idx|
        if item
          min ||= idx
        end
      end
      ptr.push(-7777)    # mark

      arr = arr[min...max]
      ent = [ arr, chkval, mkmapexp(arr), min, ptr.size - 1 ]
      all.push ent
    end

    unless defined? RegexpError
      RegexpError = RegxpError
    end
    begin
      tmp = 2 ** 16
      begin
        Regexp.new("a{#{tmp}}")
        RE_DUP_MAX = tmp
      rescue RegexpError
        tmp /= 2
        retry
      end
      raise ArgumentError, 'dummy error to clear ruby_errinfo'
    rescue ArgumentError
      ;
    end

    def mkmapexp(arr)
      i = ii = 0
      as = arr.size
      map = ''
      maxdup = RE_DUP_MAX
      curr = nil

      while i < as
        ii = i + 1
        if arr[i]
          ii += 1 while ii < as and arr[ii]
          curr = '-'
        else
          ii += 1 while ii < as and not arr[ii]
          curr = '.'
        end

        offset = ii - i
        if offset == 1
          map << curr
        else
          while offset > maxdup
            map << "#{curr}{#{maxdup}}"
            offset -= maxdup
          end
          map << "#{curr}{#{offset}}" if offset > 1
        end
        i = ii
      end

      Regexp.compile(map, 'n')
    end

    def set_table(entries, dummy, tbl, chk, ptr)
      upper = 0
      map = '-' * 10240

      # sort long to short
      entries.sort! {|a,b| b[0].size <=> a[0].size }

      entries.each do |arr, chkval, expr, min, ptri|
        if upper + arr.size > map.size
          map << '-' * (arr.size + 1024)
        end
        idx = map.index(expr)
        ptr[ptri] = idx - min
        arr.each_with_index do |item, i|
          if item
            i += idx
            tbl[i] = item
            chk[i] = chkval
            map[i] = ?o
          end
        end
        upper = idx + arr.size
      end
    end

    def act2actid(act)
      case act
      when Shift  then act.goto_id
      when Reduce then -act.ruleid
      when Accept then @states.shift_n
      when Error  then @states.reduce_n * -1
      else
        raise "racc: fatal: wrong act type #{act.class} in action table"
      end
    end

    def output_table(out, tab, label)
      if tab.size > 2000
        #
        # compressed table
        #
        output_table_c out, tab, label
      else
        #
        # normal array
        #
        output_table_s out, tab, label
      end
    end

    def output_table_c(out, tab, label)
      sep  = "\n"
      nsep = ",\n"
      buf  = ''
      com  = ''
      ncom = ','
      co   = com

      out.print 'clist = ['
      tab.each do |i|
        buf << co << i.to_s; co = ncom
        if buf.size > 66
          out.print sep; sep = nsep
          out.print "'", buf, "'"
          buf = ''
          co = com
        end
      end
      unless buf.empty?
        out.print sep
        out.print "'", buf, "'"
      end
      out.puts ' ]'

      out.print(<<EOS)
#{label} = arr = Array.new(#{tab.size}, nil)
str = a = i = nil
idx = 0
clist.each do |str|
  str.split(',', -1).each do |i|
    arr[idx] = i.to_i unless i.empty?
    idx += 1
  end
end

EOS
    end

    def output_table_s(out, tab, label)
      sep  = ''
      nsep = ','
      buf  = ''
      i = 0

      out.puts "#{label} = ["
      tab.each do |t|
        buf << sep ; sep = nsep
        if i == 10
          i = 0
          buf << "\n"
          out << buf
          buf = ''
        end
        buf << (t ? sprintf('%6d', t) : '   nil')
        i += 1
      end
      out << buf unless buf.empty?
      out.print " ]\n\n"
    end

    def output_token_table(out)
      sep = "\n"
      sep_rest = ",\n"
      out << "racc_token_table = {"
      @grammar.each_symbol.each do |sym|
        if sym.terminal?
          out.print sep; sep = sep_rest
          out.printf " %s => %d", sym.uneval, sym.ident
        end
      end
      out << " }\n\n"
    end

    def output_other(out)
      out << "racc_use_result_var = #{result_var?}\n\n"
      out.print(<<EOS)
racc_nt_base = #{@grammar.nonterminal_base}

Racc_arg = [
 racc_action_table,
 racc_action_check,
 racc_action_default,
 racc_action_pointer,
 racc_goto_table,
 racc_goto_check,
 racc_goto_default,
 racc_goto_pointer,
 racc_nt_base,
 racc_reduce_table,
 racc_token_table,
 racc_shift_n,
 racc_reduce_n,
 racc_use_result_var ]

EOS
      out << "Racc_token_to_s_table = [\n"
      out << @grammar.symbols.map {|tok|
              "'" + tok.to_s.gsub(/'/, '\\\'') + "'" }.join(",\n")
      out << "]\n\n"
      out << "Racc_debug_parser = #{debug_parser?}\n\n"
    end

    def output_actions(out)
      rl = act = nil

      if result_var?
        result1 = ', result '
        result2 = "\n   result"
        defact = ''
      else
        result1 = result2 = ''
        defact = '  val[0]'
      end
      result = result_var?() ? ', result ' : ''
      if convert_line?
        src = <<'--'

module_eval <<'.,.,', '%s', %d
  def _reduce_%d( val, _values%s)
%s%s
  end
%s
--
      else
        src = <<'--'

  def _reduce_%d( val, _values%s)
%s%s
  end
--
      end

      @grammar.each do |rl|
        act = rl.action
        if not act and omit_action_call?
          out.printf "\n # reduce %d omitted\n",
                     rl.ident
        else
          act ||= defact
          act.sub!(/\s+\z/, '')
          if convert_line?
            i = rl.lineno
            while m = /\A[ \t\f]*(?:\n|\r\n|\r)/.match(act)
              act = m.post_match
              i += 1
            end
            delim = '.,.,'
            while act.index(delim)
              delim *= 2
            end
            out.printf src, @filename, i - 1, rl.ident,
                       result1, act, result2, delim
          else
            act.sub!(/\A\s*(?:\n|\r\n|\r)/, '')
            out.printf src, rl.ident,
                       result1, act, result2
          end
        end
      end
      out.printf <<'--', result, (result_var? ? 'result' : 'val[0]')

 def _reduce_none( val, _values%s)
  %s
 end
--
      out.puts
    end

  end   # class CodeGenerator


  class LogFileGenerator

    def initialize(states, debug_flags = DebugFlags.new)
      @states = states
      @grammar = states.grammar
      @debug_flags = debug_flags
    end

    def output(out)
      output_conflict out; out.puts
      output_useless  out; out.puts
      output_rule     out; out.puts
      output_token    out; out.puts
      output_state    out
    end

    #
    # Warnings
    #

    def output_conflict(out)
      @states.each do |state|
        if state.srconf
          out.printf "state %d contains %d shift/reduce conflicts\n",
                     state.stateid, state.srconf.size
        end
        if state.rrconf
          out.printf "state %d contains %d reduce/reduce conflicts\n",
                     state.stateid, state.rrconf.size
        end
      end
    end

    def output_useless(out)
      rl = t = nil
      used = []
      @grammar.each do |rl|
        if rl.useless?
          out.printf "rule %d (%s) never reduced\n",
                     rl.ident, rl.target.to_s
        end
      end
      @grammar.each_nonterminal do |t|
        if t.useless?
          out.printf "useless nonterminal %s\n", t.to_s
        end
      end
    end

    #
    # States
    #

    def output_state(out)
      ptr = nil
      out << "--------- State ---------\n"

      showall = @debug_flags.la || @debug_flags.state
      @states.each do |state|
        out << "\nstate #{state.ident}\n\n"

        (showall ? state.closure : state.core).each do |ptr|
          pointer_out(out, ptr) if ptr.rule.ident != 0 or showall
        end
        out << "\n"

        action_out out, state
      end
    end

    def pointer_out(out, ptr)
      buf = sprintf("%4d) %s :", ptr.rule.ident, ptr.rule.target.to_s)
      ptr.rule.symbols.each_with_index do |tok, idx|
        buf << ' _' if idx == ptr.index
        buf << ' ' << tok.to_s
      end
      buf << ' _' if ptr.reduce?
      out.puts buf
    end

    def action_out(f, state)
      r = ''
      e = ''
      sr = state.srconf && state.srconf.dup
      rr = state.rrconf && state.rrconf.dup
      acts = state.action
      keys = acts.keys
      keys.sort! {|a,b| a.ident <=> b.ident }

      [ Shift, Reduce, Error, Accept ].each do |klass|
        keys.delete_if do |tok|
          act = acts[tok]
          if act.kind_of?(klass)
            outact f, tok, act
            if sr and c = sr.delete(tok)
              outsrconf f, c
            end
            if rr and c = rr.delete(tok)
              outrrconf f, c
            end

            true
          else
            false
          end
        end
      end
      sr.each {|tok, c| outsrconf f, c } if sr
      rr.each {|tok, c| outrrconf f, c } if rr

      act = state.defact
      if not act.kind_of?(Error) or @debug_flags.any?
        outact f, '$default', act
      end

      f.puts
      state.goto_table.each do |t, st|
        if t.nonterminal?
          f.printf "  %-12s  go to state %d\n", t.to_s, st.ident
        end
      end
    end

    def outact(f, t, act)
      case act
      when Shift
        f.printf "  %-12s  shift, and go to state %d\n", 
                 t.to_s, act.goto_id
      when Reduce
        f.printf "  %-12s  reduce using rule %d (%s)\n",
                 t.to_s, act.ruleid, act.rule.target.to_s
      when Accept
        f.printf "  %-12s  accept\n", t.to_s
      when Error
        f.printf "  %-12s  error\n", t.to_s
      else
        raise "racc: fatal: wrong act for outact: act=#{act}(#{act.class})"
      end
    end

    def outsrconf(f, confs)
      confs.each do |c|
        r = c.reduce
        f.printf "  %-12s  [reduce using rule %d (%s)]\n",
                 c.shift.to_s, r.ident, r.target.to_s
      end
    end

    def outrrconf(f, confs)
      confs.each do |c|
        r = c.low_prec
        f.printf "  %-12s  [reduce using rule %d (%s)]\n",
                 c.token.to_s, r.ident, r.target.to_s
      end
    end

    #
    # Rules
    #

    def output_rule(out)
      out.print "-------- Grammar --------\n\n"
      @grammar.each do |rl|
        if @debug_flags.any? or rl.ident != 0
          out.printf "rule %d %s: %s\n",
                     rl.ident, rl.target.to_s, rl.symbols.join(' ')
        end
      end
    end

    #
    # Tokens
    #

    def output_token(out)
      out.print "------- Symbols -------\n\n"

      out.print "**Nonterminals, with rules where they appear\n\n"
      @grammar.each_nonterminal do |t|
        tmp = <<SRC
  %s (%d)
    on right: %s
    on left : %s
SRC
        out.printf tmp, t.to_s, t.ident,
                   locatestr(t.locate), locatestr(t.heads)
      end

      out.print "\n**Terminals, with rules where they appear\n\n"
      @grammar.each_terminal do |t|
        out.printf "  %s (%d) %s\n",
                   t.to_s, t.ident, locatestr(t.locate)
      end
    end

    def locatestr(ptrs)
      list = ptrs.map {|ptr|
                    i = ptr.rule.ident
                    (i == 0) ? nil : i
                  }
      list.compact!
      list.uniq!
      list.join(' ')
    end

  end   # class LogFileGenerator

end
