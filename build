#!/usr/local/bin/ruby

require 'amstd/must'

require 'racc/info'
require 'racc/register'
require 'racc/state'
require 'racc/format'


def openread( fn )
  fn = File.expand_path( fn )
  f = File.open( fn )
  ret = f.read
  f.close
  ret
end

module Racc


class LALRstate
  def sr_conflict( *args )
    bug! 'sr conflict in build'
  end
  def rr_conflict( *args )
    bug! 'sr conflict in build'
  end
end
    
class Compiler

  attr :ruletable
  attr :tokentable
  attr :statetable

  def filename() '(build)' end

  def verbose() false end
  def make_profile() false end
  def debug_parser() @dflag end
  def convert_line() true end
  def omit_action() true end
  def result_var() true end

  def debug() false end
  def d_parse() false end
  def d_rule() false end
  def d_token() false end
  def d_state() false end
  def d_shift() false end
  def d_reduce() false end


  def r( symbol, rarr, act )
    symbol = @interf.get_symbol( symbol ) if symbol

    rarr.collect! do |i|
      bug! 'nil in rulearr' unless i
      @interf.get_symbol( i )
    end
    act.sub!( /\A\s*\n/, '' )
    act.sub!( /\s+\z/, '' )

    /:(\d+)(?:\z|:)/ === caller(1)[0]
    lineno = $1.to_i + 1
    rarr.push Action.new( act, lineno )

    @interf.register_rule( symbol, rarr )
  end


  def build( debugflag, index_table )
    @dflag = debugflag

    @tokentable = TokenTable.new( self )
    @ruletable  = RuleTable.new( self )
    @statetable = LALRstateTable.new( self )

    @interf = BuildInterface.new( self )

############
    # 1
    r :xclass, [ :XCLASS, :XSYMBOL, :params, :XRULE, :rules, :XEND ], %{
      @interf.end_register_rule
      @classname = val[1].id2name
    }
############
    # 2
    r :params, [], ''
    # 3
    r nil, [ :params, :param_seg ], ''
############
    # 4
    r :param_seg, [ :XCONV, :convdefs, :XEND ], %{
      @interf.end_register_conv
    }
    # 5
    r nil, [ :xprec ], ''
    # 6
    r nil, [ :XSTART, :symbol ], %{
      @interf.register_start val[1]
    }
    # 7
    r nil, [ :XTOKEN, :symbol_list ], %{
      @interf.register_token val[1]
    }
    # 8
    r nil, [ :XOPTION, :bare_symlist ], %{
      val[1].each do |s|
        @interf.register_option s.to_s
      end
    }
############
    # 7
    r :convdefs, [ :symbol, :STRING ], %{
      @interf.register_conv( val[0], val[1] )
    }
    # 8
    r nil, [ :convdefs, :symbol, :STRING ], %{
      @interf.register_conv( val[1], val[2] )
    }
############
    # 9
    r :xprec, [ :XPRECHIGH, :preclines, :XPRECLOW ], %{
      @interf.end_register_prec( true )
    }
    # 10
    r nil, [ :XPRECLOW, :preclines, :XPRECHIGH ], %{
      @interf.end_register_prec( false )
    }
############
    # 11
    r :preclines, [ :precline ], ''
    # 12
    r nil, [ :preclines, :precline ], ''
############
    # 13
    r :precline, [ :XLEFT, :symbol_list ], %{
      @interf.register_prec( :Left, val[1] )
    }
    # 14
    r nil, [ :XRIGHT, :symbol_list ], %{
      @interf.register_prec( :Right, val[1] )
    }
    # 15
    r nil, [ :XNONASSOC, :symbol_list ], %{
      @interf.register_prec( :Nonassoc, val[1] )
    }
############
    # 16
    r :symbol_list, [ :symbol ], %{
      result = val
    }
    # 17
    r nil, [ :symbol_list, :symbol ], %{
      result.push val[1]
    }
############
    # 18
    r :symbol, [ :XSYMBOL ], %{
      result = @interf.get_symbol( result )
    }
    # 19
    r nil,    [ :STRING ], %{
      result = @interf.get_symbol( eval '"' + val[0] + '"' )
    }
############
    # 20
    r :rules, [ :rules_core ], %{
      unless result.empty? then
        @interf.register_from_array result
      end
    }
    # 21
    r nil, [], ''
############
    # 22
    r :rules_core, [ :symbol ], %{
      result = val
    }
    # 23
    r nil,         [ :rules_core, :rule_item ], %{
      result.push val[1]
    }
    # 24
    r nil,         [ :rules_core, ';' ], %{
      unless result.empty? then
        @interf.register_from_array result
      end
      result.clear
    }
    # 25
    r nil,         [ :rules_core, ':' ], %{
      pre = result.pop
      unless result.empty? then
        @interf.register_from_array result
      end
      result = [pre]
    }
############
    # 26
    r :rule_item, [ :symbol ], ''
    # 27
    r nil,        [ '|' ], %{
      result = OrMark.new( @scanner.lineno )
    }
    # 28
    r nil,        [ '=', :symbol ], %{
      result = Prec.new( val[1], @scanner.lineno )
    }
    # 29
    r nil,        [ :ACTION ], %{
      result = Action.new( *result )
    }
############
    r :bare_symlist, [ :XSYMBOL ], %{
      result = [ result.id2name ]
    }
    r nil,           [ :bare_symlist, :XSYMBOL ], %{
      result.push val[1].id2name
    }
############

    @ruletable.init
    @statetable.init
    @statetable.resolve

    File.open( 'raccp.rb', 'w' ) do |f|
      f.write <<'HEADER_END'
#
# raccp.rb
#
#   Copyright (c) 1999,2000 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
#
#   This program is free software.
#   You can distribute/modify this program under the terms of
#   the GNU Lesser General Public License version 2.
#

require 'racc/parser'


module Racc

  class RaccParser < Parser

    def initialize( racc )
      @yydebug   = racc.d_parse && Racc_debug_parser
      @interf    = racc.interf
      @ruletable = racc.ruletable
    end


    attr :classname

    def parse( str )
      @scanner = RaccScanner.new( str )
      @scanner.debug = @yydebug

      do_parse
    end


    private


    def next_token
      @scanner.scan
    end

    def on_error( tok, val, _values )
      if val.respond_to? :id2name then
        v = val.id2name
      elsif String === val then
        v = val
      else
        v = val.inspect
      end
      raise ParseError, "#{@scanner.lineno}: unexpected token '#{v}'"
    end

HEADER_END
      fmt = (index_table ?
             IndexTableGenerator : AListTableGenerator).new( self )
      fmt.output( f )
      f.write <<'FOOTER_END'
  end   # class RaccParser

end   # module Racc
FOOTER_END
    end

    ver = VerboseOutputFormatter.new( self )
    File.open( 'b.output', 'w' ) do |f|
      ver.output( f )
    end
  end

end

end


de = false
ix = true
ARGV.each do |i|
  case i
  when '-g' then de = true
  when '-i' then ix = true
  when '-a' then ix = false
  end
end
Racc::Compiler.new.build de, ix
