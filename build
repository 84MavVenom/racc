#!/usr/local/bin/ruby

require 'racc/parser'

require './rule'
require './state'
require './format'


def openread( fn )
  fn = File.expand_path( fn )
  f = File.open( fn )
  ret = f.read
  f.close
  ret
end

module Racc

  Version = '0.10.6'

class Compiler

  attr :ruletable
  attr :tokentable
  attr :statetable
  attr :formatter
  attr :prectable

  def logic()  bug! 'logic called'  end
  def srconf() bug! 'srconf called' end
  def rrconf() bug! 'rrconf called' end

  def dsrc() @dflag end

  def debug() false end
  def d_prec() false end
  def d_rule() false end
  def d_token() false end
  def d_state() false end
  def d_shift() false end
  def d_reduce() false end


  def r( simbol, rarr, act )
    simbol = @interf.get_token( simbol ) if simbol

    rarr.filter do |i|
      bug! 'nil in rulearr' unless i
      @interf.get_token( i )
    end
    rarr.push Action.new( act )

    @interf.register_rule( simbol, rarr )
  end


  def build( debugflag )
    @dflag = debugflag

    @tokentable = TokenTable.new( self )
    @ruletable  = RuleTable.new( self )
    @statetable = LALRstateTable.new( self )
    @formatter  = RaccFormatter.new( self )

    @interf = BuildInterface.new( self )

############
    # 1
    r :xclass, [ :CLASS, :TOKEN, :params, :RULE, :rules, :XEND ], %{
      @interf.end_register_rule
      @classname = (Integer === val[1]) ? val[1].id2name : val[1]
    }
############
    # 2
    r :params, [], ''
    # 3
    r nil, [ :params, :param_seg ], ''
############
    # 4
    r :param_seg, [ :XTOKEN, :convdefs, :XEND ], %{
      @interf.end_register_conv
    }
    # 5
    r nil, [ :xprec ], ''
    # 6
    r nil, [ :START, :TOKEN ], %{
      if @start then
        raise ParseError, "start rule defined twice"
      end
      @start = @interf.get_token( val[1] )
    }
############
    # 7
    r :convdefs, [ :terminal, :STRING ], %{
      @interf.register_conv( val[0], val[1] )
    }
    # 8
    r nil, [ :convdefs, :terminal, :STRING ], %{
      @interf.register_conv( val[1], val[2] )
    }
############
    # 9
    r :xprec, [ :PRECHIGH, :preclines, :PRECLOW ], %{
      @interf.end_register_prec( true )
    }
    # 10
    r nil, [ :PRECLOW, :preclines, :PRECHIGH ], %{
      @interf.end_register_prec( false )
    }
############
    # 11
    r :preclines, [ :precline ], ''
    # 12
    r nil, [ :preclines, :precline ], ''
############
    # 13
    r :precline, [ :LEFT, :term_list ], %{
      @interf.register_prec( :Left, val[1] )
    }
    # 14
    r nil, [ :RIGHT, :term_list ], %{
      @interf.register_prec( :Right, val[1] )
    }
    # 15
    r nil, [ :NONASSOC, :term_list ], %{
      @interf.register_prec( :Nonassoc, val[1] )
    }
############
    # 16
    r :term_list, [ :terminal ], %{
      result = val
    }
    # 17
    r nil, [ :term_list, :terminal ], %{
      result.push val[1]
    }
############
    # 26
    r :terminal, [ :TOKEN ], %{
      result = @interf.get_token( val[0] )
    }
    # 27
    r nil,     [ :STRING ], %{
      result = @interf.get_token( eval '"' + val[0] + '"' )
    }
############
    # 18
    r :rules, [ :ruleseg, ';' ], ''
    # 19
    r nil, [ :rules, :ruleseg, ';' ], ''
############
    # 20
    r :ruleseg, [ :TOKEN, ':', :simbol_list ], %{
      @interf.register_rule @interf.get_token(val[0]), val[2]
    }
    # 21
    r nil, [ :ruleseg, '|', :simbol_list ], %{
      @interf.register_rule nil, val[2]
    }
############
    # 22
    r :simbol_list, [], %{
      result = []
    }
    # 23
    r nil, [ :simbol_list, :simbol ], %{
      result.push val[1] if val[1]
    }
############
    # 24
    r :simbol, [ :TOKEN ], %{
      result = @interf.get_token( val[0] )
    }
    # 25
    r nil,     [ :STRING ], %^
      result = @interf.get_token( eval %<"\#{result}"> )
    ^
    # 26
    r nil,     [ :ACTION ], %{
      result = Action.new( result )
    }
    # 27
    r nil,     [ '=', :terminal ], %{
      @interf.register_tmpprec val[1]
      result = nil
    }
############

    @ruletable.do_initialize
    @statetable.do_initialize
    @statetable.resolve

    File.open( 'raccp.rb', 'w' ) do |f|
      f.write openread( 'p.prepare' )
      f.puts "  class RaccParser < Parser"
      f.write openread( 'p.inner' )
      @formatter.source( f )
      f.puts '  end   # class RaccParser'
      f.puts
      f.puts 'end   # module Racc'
    end

    File.open( 'b.output', 'w' ) do |f|
      formatter.output_rule f
      formatter.output_token f
      formatter.output_state f
    end
  end

end

end


Racc::Compiler.new.build( (ARGV[0] == '-g') )
