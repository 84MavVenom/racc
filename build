#!/usr/local/bin/ruby

require 'amstd/must'

require 'racc/register'
require 'racc/rule'
require 'racc/state'
require 'racc/format'


def openread( fn )
  fn = File.expand_path( fn )
  f = File.open( fn )
  ret = f.read
  f.close
  ret
end

module Racc

  Version = '0.14.4'

class LALRstate
  def sr_conflict( *args )
    bug! 'sr conflict in build'
  end
  def rr_conflict( *args )
    bug! 'sr conflict in build'
  end
end
    
class Compiler

  attr :ruletable
  attr :tokentable
  attr :statetable

  class Par
    def filename() '(build)' end
  end
  DUMMY = Par.new
  def parser() DUMMY end

  def dsrc() @dflag end

  def debug() false end
  def d_prec() false end
  def d_rule() false end
  def d_token() false end
  def d_state() false end
  def d_shift() false end
  def d_reduce() false end
  def d_prof() false end


  def r( simbol, rarr, act )
    simbol = @interf.get_token( simbol ) if simbol

    rarr.filter do |i|
      bug! 'nil in rulearr' unless i
      @interf.get_token( i )
    end
    act.sub!( /\A\s*\n/, '' )
    act.sub!( /\s+\z/, '' )

    /:(\d+)(?:\z|:)/ === caller(1)[0]
    lineno = $1.to_i + 1
    rarr.push Action.new( act, lineno )

    @interf.register_rule( simbol, rarr )
  end


  def build( debugflag, index_table )
    @dflag = debugflag

    @tokentable = TokenTable.new( self )
    @ruletable  = RuleTable.new( self )
    @statetable = LALRstateTable.new( self )

    @interf = BuildInterface.new( self )

############
    # 1
    r :xclass, [ :XCLASS, :TOKEN, :params, :XRULE, :rules, :XEND ], %{
      @interf.end_register_rule
      @classname = val[1].id2name
    }
############
    # 2
    r :params, [], ''
    # 3
    r nil, [ :params, :param_seg ], ''
############
    # 4
    r :param_seg, [ :XTOKEN, :convdefs, :XEND ], %{
      @interf.end_register_conv
    }
    # 5
    r nil, [ :xprec ], ''
    # 6
    r nil, [ :XSTART, :token ], %{
      @interf.register_start val[1]
    }
############
    # 7
    r :convdefs, [ :token, :STRING ], %{
      @interf.register_conv( val[0], val[1] )
    }
    # 8
    r nil, [ :convdefs, :token, :STRING ], %{
      @interf.register_conv( val[1], val[2] )
    }
############
    # 9
    r :xprec, [ :XPRECHIGH, :preclines, :XPRECLOW ], %{
      @interf.end_register_prec( true )
    }
    # 10
    r nil, [ :XPRECLOW, :preclines, :XPRECHIGH ], %{
      @interf.end_register_prec( false )
    }
############
    # 11
    r :preclines, [ :precline ], ''
    # 12
    r nil, [ :preclines, :precline ], ''
############
    # 13
    r :precline, [ :XLEFT, :token_list ], %{
      @interf.register_prec( :Left, val[1] )
    }
    # 14
    r nil, [ :XRIGHT, :token_list ], %{
      @interf.register_prec( :Right, val[1] )
    }
    # 15
    r nil, [ :XNONASSOC, :token_list ], %{
      @interf.register_prec( :Nonassoc, val[1] )
    }
############
    # 16
    r :token_list, [ :token ], %{
      result = val
    }
    # 17
    r nil, [ :token_list, :token ], %{
      result.push val[1]
    }
############
    # 18
    r :token, [ :TOKEN ], %{
      result = @interf.get_token( result )
    }
    # 19
    r nil,    [ :STRING ], %{
      result = @interf.get_token( eval '"' + val[0] + '"' )
    }
############
    # 20
    r :rules, [ :rules_core ], %{
      unless result.empty? then
        @interf.register_from_array result
      end
    }
############
    # 21
    r :rules_core, [ :token ], %{
      result = val
    }
    # 22
    r nil,         [ :rules_core, :rule_item ], %{
      result.push val[1]
    }
    # 23
    r nil,         [ :rules_core, ';' ], %{
      unless result.empty? then
        @interf.register_from_array result
      end
      result.clear
    }
    # 24
    r nil,         [ :rules_core, ':' ], %{
      pre = result.pop
      unless result.empty? then
        @interf.register_from_array result
      end
      result = [pre]
    }
############
    # 25
    r :rule_item, [ :token ], ''
    # 26
    r nil,        [ '|' ], %{
      result = OrMark.new( @scanner.lineno )
    }
    # 27
    r nil,        [ '=', :token ], %{
      result = Prec.new( val[1], @scanner.lineno )
    }
    # 28
    r nil,        [ :ACTION ], %{
      result = Action.new( *result )
    }
############

    @ruletable.init
    @tokentable.init
    @statetable.init
    @statetable.resolve

    File.open( 'raccp.rb', 'w' ) do |f|
      f.write <<'HEADER_END'
#
# raccp.rb
#
#   Copyright (c) 1999 Minero Aoki <aamine@dp.u-netsurf.ne.jp>
#
#   This program is free software.
#   You can distribute/modify this program under the terms of
#   the GNU Library General Public License.
#

require 'racc/parser'
require 'amstd/symbol'


module Racc

  class RaccParser < Parser

    def initialize( racc )
      @racc = racc
      @interf    = racc.interf
      @ruletable = racc.ruletable
    end


    attr :classname

    attr :filename

    def parse( str, fname, mydebug = false )
      fname.must String
      
      @scanner = RaccScanner.new( str )
      @scanner.debug    = @yydebug  = mydebug
      @scanner.filename = @filename = fname

      do_parse
    end


    private


    def next_token
      @scanner.scan
    end

    def on_error( tok, val, _values )
      case val
      when Symbol then v = val.id2name
      when String then v = val
      else
        v = val.inspect
      end
      raise ParseError,
%=parse error:#{@filename}:#{@scanner.lineno}: unexpected token '#{v}'=
    end

HEADER_END
      fmt = (index_table ?
             IndexTableGenerator : AListTableGenerator).new( self )
      fmt.output( f )
      f.write <<'FOOTER_END'
  end   # class RaccParser

end   # module Racc
FOOTER_END
    end

    ver = VerboseOutputFormatter.new( self )
    File.open( 'b.output', 'w' ) do |f|
      ver.output( f )
    end
  end

end

end


de = false
ix = true
ARGV.each do |i|
  case i
  when '-g' then de = true
  when '-i' then ix = true
  when '-a' then ix = false
  end
end
Racc::Compiler.new.build de, ix
